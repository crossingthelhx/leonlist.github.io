<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CTF密码学-RSA | Leonlist's Blog</title><meta name="description" content="数学基础素数与互素数1.素数： 一个数如果除了 1 与它本身之外没有其他的因数，那么这个数就被称为素数。 任意一个整数 (a &gt; 1) 都能分解为 n 个素数之积。 2.合数： 如果一个数大于 1，且该数本身不是素数，那么这个数就是一个合数。 3.互质数： 如果两个整数 a，b 的最大公因数 gcd(a, b) &#x3D; 1，那么称 a，b 两数互质。 由于要求最大公因子为正，所以 gcd(a,"><meta name="keywords" content="RSA,CTF"><meta name="author" content="Leonlist"><meta name="copyright" content="Leonlist"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://yoursite.com/2020/09/21/CTF%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="CTF密码学-RSA"><meta property="og:url" content="http://yoursite.com/2020/09/21/CTF%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/"><meta property="og:site_name" content="Leonlist's Blog"><meta property="og:description" content="数学基础素数与互素数1.素数： 一个数如果除了 1 与它本身之外没有其他的因数，那么这个数就被称为素数。 任意一个整数 (a &gt; 1) 都能分解为 n 个素数之积。 2.合数： 如果一个数大于 1，且该数本身不是素数，那么这个数就是一个合数。 3.互质数： 如果两个整数 a，b 的最大公因数 gcd(a, b) &#x3D; 1，那么称 a，b 两数互质。 由于要求最大公因子为正，所以 gcd(a,"><meta property="og:image" content="https://i.loli.net/2019/11/10/53eTB2uiNRlXwFP.png"><meta property="article:published_time" content="2020-09-21T07:21:07.000Z"><meta property="article:modified_time" content="2020-10-05T12:50:10.020Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime: '',
  last_push_date: {"zeroDay":"Today","suffix":"days ago"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-05 20:50:10'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/logo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">数学基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0%E4%B8%8E%E4%BA%92%E7%B4%A0%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">素数与互素数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">欧几里得算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.</span> <span class="toc-text">模运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">扩展欧几里得算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E5%92%8C%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">费马小定理和欧拉定理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">中国剩余定理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RSA%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">RSA算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RSA%E5%B8%B8%E7%94%A8%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">RSA常用攻击方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%95%B0N%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB"><span class="toc-number">3.1.</span> <span class="toc-text">模数N相关攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%86%E8%A7%A3N"><span class="toc-number">3.1.1.</span> <span class="toc-text">直接分解N</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AAN%E4%B8%8D%E4%BA%92%E7%B4%A0"><span class="toc-number">3.1.2.</span> <span class="toc-text">两个N不互素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8CN%EF%BC%8C%E4%B8%8D%E5%90%8Ce%E5%8A%A0%E5%AF%86%E5%90%8C%E6%98%8E%E6%96%87m"><span class="toc-number">3.1.3.</span> <span class="toc-text">同N，不同e加密同明文m</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Return-of-Coppersmith%E2%80%99s-attack%E6%94%BB%E5%87%BB"><span class="toc-number">3.1.4.</span> <span class="toc-text">Return of Coppersmith’s attack攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E9%92%A5%E6%8C%87%E6%95%B0e%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB"><span class="toc-number">3.2.</span> <span class="toc-text">公钥指数e相关攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#e%E5%BE%88%E5%B0%8F%E4%B8%94%E6%98%8E%E6%96%87m%E6%AF%94%E8%BE%83%E5%B0%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">e很小且明文m比较小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e%E4%B8%8E%E6%A8%A1%E6%95%B0N%E7%9A%84%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E7%B4%A0%E6%95%B0%E5%9B%A0%E5%AD%90%E7%9A%84%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E4%B8%8D%E4%BA%92%E7%B4%A0"><span class="toc-number">3.2.2.</span> <span class="toc-text">e与模数N的一个或多个素数因子的欧拉函数不互素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e-3%EF%BC%8C%E6%A8%A1%E6%95%B0N%E7%9B%B8%E5%90%8C%EF%BC%8C%E4%B8%94%E6%98%8E%E6%96%87%E5%AD%98%E5%9C%A8%E7%BA%BF%E6%80%A7%E5%85%B3%E7%B3%BBm1-a-m2-b-mod-N"><span class="toc-number">3.2.3.</span> <span class="toc-text">e&#x3D;3，模数N相同，且明文存在线性关系m1&#x3D;a*m2+b mod N</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wiener-attack"><span class="toc-number">3.2.4.</span> <span class="toc-text">Wiener_attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boneh-and-Durfee-attack"><span class="toc-number">3.2.5.</span> <span class="toc-text">Boneh and Durfee attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E5%8A%A0%E5%AF%86%E6%8C%87%E6%95%B0%E5%B9%BF%E6%92%AD%E6%94%BB%E5%87%BB"><span class="toc-number">3.2.6.</span> <span class="toc-text">低加密指数广播攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e%E9%9D%9E%E7%B4%A0%E6%95%B0"><span class="toc-number">3.2.7.</span> <span class="toc-text">e非素数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Coppersmith%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB"><span class="toc-number">3.3.</span> <span class="toc-text">Coppersmith相关攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Coppersmith%E2%80%99s-short-pad-attack"><span class="toc-number">3.3.1.</span> <span class="toc-text">Coppersmith’s short-pad attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hastad%E2%80%99s-Broadcast-Attack-with-Linear-Padding"><span class="toc-number">3.3.2.</span> <span class="toc-text">Hastad’s Broadcast Attack with Linear Padding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stereotyped-messages%E6%94%BB%E5%87%BB"><span class="toc-number">3.3.3.</span> <span class="toc-text">Stereotyped messages攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial-Key-Exposure-Attack"><span class="toc-number">3.3.4.</span> <span class="toc-text">Partial Key Exposure Attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial-Key-Recovery-Attack"><span class="toc-number">3.3.5.</span> <span class="toc-text">Partial Key Recovery Attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Factoring-with-high-bits-known%E6%94%BB%E5%87%BB"><span class="toc-number">3.3.6.</span> <span class="toc-text">Factoring with high bits known攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.7.</span> <span class="toc-text"> </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%9D%A1%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB"><span class="toc-number">3.4.</span> <span class="toc-text">其他条件相关攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5p%EF%BC%8Cq%E5%85%B6%E4%BB%96%E7%AD%89%E5%BC%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">已知p，q其他等式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dp-amp-dq%E6%B3%84%E9%9C%B2"><span class="toc-number">3.4.2.</span> <span class="toc-text">dp&amp;dq泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dp%E6%B3%84%E9%9C%B2"><span class="toc-number">3.4.3.</span> <span class="toc-text">dp泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%B4%A0%E6%95%B0%E5%9B%A0%E5%AD%90"><span class="toc-number">3.4.4.</span> <span class="toc-text">多素数因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86"><span class="toc-number">3.4.5.</span> <span class="toc-text">费马小定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next-prime"><span class="toc-number">3.4.6.</span> <span class="toc-text">next_prime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LLL%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.7.</span> <span class="toc-text">LLL算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e-%E5%92%8C-phi-n-%E4%B8%8D%E4%BA%92%E7%B4%A0"><span class="toc-number">3.4.8.</span> <span class="toc-text">e 和 phi(n) 不互素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E6%94%BB%E5%87%BB"><span class="toc-number">3.4.9.</span> <span class="toc-text">选择密文攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LSB-Oracle-Attack"><span class="toc-number">3.4.10.</span> <span class="toc-text">LSB Oracle Attack</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2019/11/10/53eTB2uiNRlXwFP.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leonlist's Blog</a></span><span class="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">CTF密码学-RSA</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-09-21T07:21:07.000Z" title="Created 2020-09-21 15:21:07">2020-09-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-10-05T12:50:10.020Z" title="Updated 2020-10-05 20:50:10">2020-10-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/">CTF</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/Crypto%E5%AD%A6%E4%B9%A0/">Crypto学习</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="素数与互素数"><a href="#素数与互素数" class="headerlink" title="素数与互素数"></a>素数与互素数</h2><p><strong>1.素数：</strong></p>
<p>一个数如果除了 1 与它本身之外没有其他的因数，那么这个数就被称为素数。</p>
<p>任意一个整数 (a &gt; 1) 都能分解为 n 个素数之积。</p>
<p><strong>2.合数：</strong></p>
<p>如果一个数大于 1，且该数本身不是素数，那么这个数就是一个合数。</p>
<p><strong>3.互质数：</strong></p>
<p>如果两个整数 a，b 的最大公因数 gcd(a, b) = 1，那么称 a，b 两数互质。</p>
<p>由于要求最大公因子为正，所以 gcd(a, b) = gcd(a, -b) = gcd(-a, b) = gcd(-a, -b)。一般gcd(a, b) = gcd(|a|, |b|)。由任一非 0 整数能整除0，可得 gcd(a, 0) = |a|。如果将 a, b 都表示为素数的乘积，则 gcd(a, b) 极易确定。</p>
<h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>对于一个大整数而言，我们很难去因式分解，欧几里得算法提供了一个更有效的算法计算 gcd，这个算法基于一简单的观察，即：</p>
<p>$gcd(r_0,r_1)=gcd(r_0-r_1,r_1)$</p>
<p>其中，通常假设$r_0 &gt;r_1$，并且两个数均为正整数。此属性的证明非常简单：</p>
<p>假设 $gcd(r_0,r_1)=g$，由于 g 可以同时除 $r_0$ 和 $r_1$，则可以记作 $r_0=g\cdot x$ 和 $r_1 = g\cdot y$，其中 $x&gt;y$，且 x 和 y 为互素的整数，即它们没有公共因子。此外，证明（x - y）与 y 互素也非常简单。因此可以得到：</p>
<p>$gcd(r_0-r_1, r_1) = gcd(g\cdot (x-y),g\cdot y)=g$</p>
<p>即使处理非常长的数字（这些数字通常在公钥密码学中使用），欧几里得算法依然高效。迭代次数与输入操作数的位数有紧密的关系。这意味着如果一个 gcd 涉及的数字都是 1024 位，则此 gcd 的迭代次数就是 1024 乘以一个常数。几千次迭代的算法在当今 PC 上很容易实现。</p>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>设n是一正整数，a 是整数，如果用 n 除 a，得商为 q，余数为 r，则</p>
<p>$a=qn+r,0\leq r\leq n,q=\lfloor \frac {a}{n}\rfloor$</p>
<p>$\lfloor \frac {a}{n}\rfloor$表示对$\frac {a}{n}$进行下取整</p>
<p>用 $a\space mod\space n$ 表示余数 $r$，则$a=\lfloor \frac {a}{n}\rfloor n+amodn$。</p>
<p>如果$a\space mod\space n=b\space mod\space n$，则称两整数 $a$ 和 $b$ 模 $n$ 同余，记为$a≡b\space mod\space n$。称与 $a$ 模 $n$ 同余的数的全体为 $a$ 的同余类，记为$[a]$，称 $a$ 为这个同余类的表示元素。</p>
<p>注意： 如果$a≡0\space mod\space n$，则 $n$ |$a$</p>
<p>同余有以下性质：</p>
<p>① 若 $n$ | $(a-b)$，则 $a≡b\space mod\space n$</p>
<p>② $a\space mod\space n≡b\space mod\space n$，则$a≡b\space mod\space n$</p>
<p>③ $a≡b\space mod\space n$,则 $b≡a\space mod\space n$</p>
<p>④ $a≡b\space mod\space n$，$b≡c\space mod\space n$，则$a≡c\space mod\space n$</p>
<p>从以上性质易知，同余类中的每一元素都可作为这个同余类的表示元素。</p>
<p>求余数运算（简称求余运算）a mod n 将整数 a 映射到集合 {0,1, …,n-1}，称求余运算在这个集合上的算术运算为模运算，模运算有以下性质：</p>
<p>① $[(a\space mod\space n)+(b\space mod\space n)] mod\space n=(a+b) mod\space n$。</p>
<p>② $[(a\space mod\space n)-(b\space mod\space n)] mod\space n=(a-b)\space mod\space n$。</p>
<p>③ $[(a\space mod\space n)×(b\space mod\space n)] mod\space n=(a×b)\space mod\space n$。</p>
<p>性质①的证明： 设 $a\space mod\space n=r_a$，$b\space mod\space n=r_b$，则存在整数$j$、$k$ 使得 $a=j\cdot n+r_a$，$b=k\cdot n+r_b$。</p>
<p>因此</p>
<p>$(a+b)\space mod\space n=[(j+k)n+r_a+r_b]\space mod\space n=(r_a+r_b)\space mod\space n= [(a\space mod\space n)+(b\space mod\space n)]\space mod\space n$</p>
<p>性质②、③的证明类似。</p>
<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>在欧几里得算法的时候我们已经知道两个整数 $r_0$ 和 $r_1$ 的 gcd 的计算可以通过不断进行迭代地减小操作数来实现。然而，事实证明，欧几里得算法的主要应用并不在计算 gcd。扩展的欧几里得算法可以用来计算模逆元，而模逆元在公钥密码学中占有举重若轻的地位。拓展的欧几里得算法除了可以计算 gcd 外，还能计算以下形式的线性组合：</p>
<p>$gcd(r_0,r_1)=s\cdot r_0+t\cdot r_1$</p>
<p>其中s和t均表示整型系数。这个等式通常也称为丢番图方程。</p>
<p>这个算法的思路是：执行标准欧几里得算法，但将每轮迭代中的余数 $r_i$ 表示为以下形式的线性组合：</p>
<p>$r_i=s_ir_0+t_ir_i$</p>
<p>如果这个过程成功了，则最后一轮迭代对应的等式为：</p>
<p>$r_i=gcd(r_0,r_1)=s_ir_0+t_ir_1=sr_0+tr_1$</p>
<p>这也意味着最后一个系数 $s_i$ 也是等式所寻找的系数 s，同时 $t_i=t$。</p>
<h2 id="费马小定理和欧拉定理"><a href="#费马小定理和欧拉定理" class="headerlink" title="费马小定理和欧拉定理"></a>费马小定理和欧拉定理</h2><p><strong>1.费马小定理</strong></p>
<p>定理：若 p 是素数，a 是正整数且 $gcd(a, p)=1$，则 $a^{p-1}≡1\space mod\space p$。</p>
<p>费马小定理也可写成如下形式： 设 p 是素数，a 是任一正整数，则$a^{p}\equiv a\space mod\space p$。</p>
<p><strong>2.欧拉函数</strong></p>
<p>定理: 若 n 是两个素数 p 和 q 的乘积，则$\phi (n)=\phi (p)× \phi (q)=(p-1)×(q-1)$。</p>
<p>设 n 是一正整数，小于n且与n互素的正整数的个数称为n的欧拉函数，记为$\phi (n)$。</p>
<p>例如： $\phi (6)=2$ ，$\phi (7)=6$ ，$\phi (8)=4$。</p>
<p>若n是素数，则显然有 $\phi (n)=n-1$。</p>
<p>定理：若a和n互素，则 $aφ(n) ≡ 1\space mod\space n$。</p>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>中国剩余定理是数论中最有用的一个工具，定理说如果已知某个数关于一些两两互素的数的同余类集，就可重构这个数。</p>
<p>例如：$Z_{10}$ 中每个数都可从这个数关于 2 和 5（10的两个互素的因子）的同余类重构。比如已知 x 关于 2 和 5 的同余类分别是 [0] 和 [3]，即 x mod 2 ≡ 0，x mod 5 ≡ 3。可知是偶数且被 5 除后余数是 3，所以可得 8 是满足这一关系的惟一的 x。</p>
<p>例如: 求 $12\times 13(mod\space 15)$</p>
<p>因为 12 和 13 所在的行号分别为 0 和 1，12 和 13 所在的列号分别为 2 和 3，由$0\times 1\equiv 0\space mod\space 3$; $2\times 3\equiv 1\space mod\space 5$ 得$12\times 13(mod\space 15)$所在的列号和行号分别为 0 和 1，这个位置上的数是6，所以得到$12\times 13(mod\space 15)\equiv 6$。</p>
<p>又因为 $0+1\equiv 1\space mod\space 3$; $2+3\equiv 0\space mod\space 5$第 1 行、第 0 列为 10，所以$12+13\equiv 10\space mod\space 15$。</p>
<p><strong>中国剩余定理：</strong></p>
<p>设 $m_1,m_2,…,m_k$ 是两两互素的正整数，$M=$ 一次同余方程组</p>
<script type="math/tex; mode=display">
\begin{cases}a_1(mod \space m_1) \equiv x \\a_2(mod \space m_2) \equiv x \\ ... \\a_k(mod \space m_k) \equiv x\end{cases}</script><p>对模M有惟一解:</p>
<p>$x\equiv (\frac{M}{m_1}e_1a_1+\frac{M}{m_2}e_2a_2+…+\frac{M}{m_k}e_ka_k)(mod \space M)$</p>
<p>其中 $e_i$ 满足$\frac{M}{m_i}e_i\equiv 1(mod\space m_i)\space(i=1,2,…,k)$</p>
<h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><p><strong>1．密钥生成</strong></p>
<p>① 选取两个保密的大素数 p 和 q。</p>
<p>② 计算 $n = p\times q$，$\phi (n)=(p-1)(q-1)$，其中是n的欧拉函数值。</p>
<p>③ 随机选取整数 e，满足 $1 &lt; e &lt; \phi (n) $ ，且 $gcd(e,\phi (n))=1$。</p>
<p>④ 计算 d，满足。$de\equiv 1\space mod \space \phi (n)$</p>
<p>⑤ 公钥为 $(e,n)$，私钥为 $(d, n)$。</p>
<p><strong>2．加密</strong></p>
<p>将明文转换成十进制数，则加密算法为：</p>
<p>$c=m^e\space mod \space n$</p>
<p>c为密文，且 $0 ≤ c &lt; n$。</p>
<p><strong>3．解密</strong></p>
<p>对于密文0≤c＜n，解密算法为：</p>
<p>$m=c^d \space mod \space n$</p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/CTF%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/4-3-1-3.png" alt="4-3-1-3" style="zoom:67%;" /></p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/CTF%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/4-3-1-4.png" alt="4-3-1-4" style="zoom:67%;" /></p>
<p><strong>RSA安全性分析</strong></p>
<p>对于 RSA 加密算法，公钥 (N, e) 为公钥，可以任意公开，破解 RSA 最直接（亦或是暴力）的方法就是分解整数 N，然后计算欧拉函数 φ(n) = (p-1) <em> (q-1)，再通过 d </em> e ≡ 1 mod φ(N)，即可计算出 d，然后就可以使用私钥 (N, d) 通过 m = pow(c,d,N) 解密明文。</p>
<h1 id="RSA常用攻击方法"><a href="#RSA常用攻击方法" class="headerlink" title="RSA常用攻击方法"></a>RSA常用攻击方法</h1><h2 id="模数N相关攻击"><a href="#模数N相关攻击" class="headerlink" title="模数N相关攻击"></a>模数N相关攻击</h2><h3 id="直接分解N"><a href="#直接分解N" class="headerlink" title="直接分解N"></a>直接分解N</h3><ul>
<li><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/yafu/">yafu</a></li>
</ul>
<p>p，q 差值太大或者太小，适用 Fermat 或 Pollard rho 法分解</p>
<p>使用方法：</p>
<p>打开 yafu-x64.exe。</p>
<p>最常用的命令是 factor(n)，将n值分解。</p>
<p>使用 yafu 的时候遇到 mismatched parens：</p>
<p>这是因为在命令行里不支持过长的位数，所以我们只要把n的值从文件中去读取即可。</p>
<p>新建一个文件 pcat.txt，内容里写上 n 的值，如：</p>
<p>注意：<strong>最后面一定要换行</strong>，不然会出现 eof; done processing batchfile</p>
<p>然后运行命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yafu-x64 &quot;factor(@)&quot; -batchfile pcat.txt</span><br></pre></td></tr></table></figure>
<p>输出的结果在 factor.txt 里。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://factordb.com/">factordb网站</a>：N 比特位数 768 或更高，在线网站会存储一些已分解成功的 N。</li>
</ul>
<h3 id="两个N不互素"><a href="#两个N不互素" class="headerlink" title="两个N不互素"></a>两个N不互素</h3><p>通过欧几里德算法求 N1 和 N2 的最大公约数 gmpy2.gcd(n1, n2)，即求得 N 的任意一个因子 p。</p>
<h3 id="同N，不同e加密同明文m"><a href="#同N，不同e加密同明文m" class="headerlink" title="同N，不同e加密同明文m"></a>同N，不同e加密同明文m</h3><p>通过扩展欧几里德算法求出满足 se1 + te2 = 1 mod N 的 s 和 t，再结合对应的密文 c1 和 c2 求得明文 m。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcd, s, t = gmpy2.gcdext(e1, e2)</span><br><span class="line">m = gmpy2.powmod(c1, s, N) * gmpy2.powmod(c2, t, N) % N</span><br></pre></td></tr></table></figure>
<h3 id="Return-of-Coppersmith’s-attack攻击"><a href="#Return-of-Coppersmith’s-attack攻击" class="headerlink" title="Return of Coppersmith’s attack攻击"></a>Return of Coppersmith’s attack攻击</h3><p>素数生成有漏洞，不够随机，实际上的生成方式是用 p = k * M + (65537 ^ a % M) 生成的，其中 M 为前 x 个素数乘积。</p>
<p>素数的生成算法不安全，攻击方法由论文可知。</p>
<p><a target="_blank" rel="noopener" href="https://crocs.fi.muni.cz/public/papers/rsa_ccs17">https://crocs.fi.muni.cz/public/papers/rsa_ccs17</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#p,q=k*M+(65537**a %M)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hardcoded parameters for efficiency</span></span><br><span class="line"><span class="comment"># Found using params.py</span></span><br><span class="line">param = \</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">512</span>: &#123;</span><br><span class="line">    <span class="string">&quot;n&quot;</span>: <span class="number">39</span>,</span><br><span class="line">    <span class="string">&quot;a_max&quot;</span>: <span class="number">62</span>,</span><br><span class="line">    <span class="string">&quot;k_max&quot;</span>: <span class="number">37</span>,</span><br><span class="line">    <span class="string">&quot;M&quot;</span>: <span class="number">0x924cba6ae99dfa084537facc54948df0c23da044d8cabe0edd75bc6</span>,</span><br><span class="line">    <span class="string">&quot;M_prime&quot;</span>: <span class="number">0x1b3e6c9433a7735fa5fc479ffe4027e13bea</span>,</span><br><span class="line">    <span class="string">&quot;m&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;t&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;c_a&quot;</span>: <span class="number">0x80000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1024</span>: &#123;</span><br><span class="line">    <span class="string">&quot;n&quot;</span>: <span class="number">71</span>,</span><br><span class="line">    <span class="string">&quot;a_max&quot;</span>: <span class="number">134</span>,</span><br><span class="line">    <span class="string">&quot;k_max&quot;</span>: <span class="number">37</span>,</span><br><span class="line">    <span class="string">&quot;M&quot;</span>: <span class="number">0x7923ba25d1263232812ac930e9683ac0b02180c32bae1d77aa950c4a18a4e660db8cc90384a394940593408f192de1a05e1b61673ac499416088382</span>,</span><br><span class="line">    <span class="string">&quot;M_prime&quot;</span>: <span class="number">0x24683144f41188c2b1d6a217f81f12888e4e6513c43f3f60e72af8bd9728807483425d1e</span>,</span><br><span class="line">    <span class="string">&quot;m&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">&quot;t&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;c_a&quot;</span>: <span class="number">0x40000000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">2048</span>: &#123;</span><br><span class="line">    <span class="string">&quot;n&quot;</span>: <span class="number">126</span>,</span><br><span class="line">    <span class="string">&quot;a_max&quot;</span>: <span class="number">434</span>,</span><br><span class="line">    <span class="string">&quot;k_max&quot;</span>: <span class="number">53</span>,</span><br><span class="line">    <span class="string">&quot;M&quot;</span>: <span class="number">0x7cda79f57f60a9b65478052f383ad7dadb714b4f4ac069997c7ff23d34d075fca08fdf20f95fbc5f0a981d65c3a3ee7ff74d769da52e948d6b0270dd736ef61fa99a54f80fb22091b055885dc22b9f17562778dfb2aeac87f51de339f71731d207c0af3244d35129feba028a48402247f4ba1d2b6d0755baff6</span>,</span><br><span class="line">    <span class="string">&quot;M_prime&quot;</span>: <span class="number">0x16928dc3e47b44daf289a60e80e1fc6bd7648d7ef60d1890f3e0a9455efe0abdb7a748131413cebd2e36a76a355c1b664be462e115ac330f9c13344f8f3d1034a02c23396e6</span>,</span><br><span class="line">    <span class="string">&quot;m&quot;</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="string">&quot;t&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="string">&quot;c_a&quot;</span>: <span class="number">0x400000000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/coppersmith.sage</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coppersmith_howgrave_univariate</span>(<span class="params">pol, N, beta, mm, tt, XX</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Coppersmith revisited by Howgrave-Graham</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    finds a solution if:</span></span><br><span class="line"><span class="string">    * b|N, b &gt;= N^beta , 0 &lt; beta &lt;= 1</span></span><br><span class="line"><span class="string">    * |x| &lt; XX</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># init</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    dd = pol.degree()</span><br><span class="line">    nn = dd * mm + tt</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># checks</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt; beta &lt;= <span class="number">1</span> :</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;beta should belongs in (0, 1]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pol.is_monic():</span><br><span class="line">        <span class="keyword">raise</span> ArithmeticError(<span class="string">&quot;Polynomial must be monic.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Coppersmith revisited algo for univariate</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># change ring of pol and x</span></span><br><span class="line">    polZ = pol.change_ring(ZZ)</span><br><span class="line">    x = polZ.parent().gen()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute polynomials</span></span><br><span class="line">    gg = []</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(mm):</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(dd):</span><br><span class="line">            gg.append((x * XX)**jj * N**(mm - ii) * polZ(x * XX)**ii)</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(tt):</span><br><span class="line">        gg.append((x * XX)**ii * polZ(x * XX)**mm)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct lattice B</span></span><br><span class="line">    BB = Matrix(ZZ, nn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(nn):</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(ii+<span class="number">1</span>):</span><br><span class="line">            BB[ii, jj] = gg[ii][jj]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># LLL</span></span><br><span class="line">    BB = BB.LLL(early_red=<span class="literal">True</span>, use_siegel=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># transform shortest vector in polynomial</span></span><br><span class="line">    new_pol = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(nn):</span><br><span class="line">        new_pol += x**ii * BB[<span class="number">0</span>, ii] / XX**ii</span><br><span class="line"></span><br><span class="line">    <span class="comment"># factor polynomial</span></span><br><span class="line">    potential_roots = new_pol.roots()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> potential_roots]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Top level of the attack, feeds the queue for the workers</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roca</span>(<span class="params">N</span>):</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Key is not always of perfect size, infer from size</span></span><br><span class="line">  keylength = int(log(N, <span class="number">2</span>))</span><br><span class="line">  <span class="keyword">if</span> keylength &lt; <span class="number">1000</span> :</span><br><span class="line">    keylength = <span class="number">512</span></span><br><span class="line">  <span class="keyword">elif</span>  keylength &lt; <span class="number">2000</span> :</span><br><span class="line">    keylength = <span class="number">1024</span></span><br><span class="line">  <span class="keyword">elif</span> keylength &lt; <span class="number">4000</span> :</span><br><span class="line">    keylength = <span class="number">2048</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    keylength = <span class="number">4096</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># bruteforce</span></span><br><span class="line">  M_prime = param[keylength][<span class="string">&#x27;M_prime&#x27;</span>]</span><br><span class="line">  c_prime = discrete_log(N, Mod(<span class="number">65537</span>, M_prime))</span><br><span class="line">  ord_prime = Zmod(M_prime)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line">  top = (c_prime + ord_prime)/<span class="number">2</span></span><br><span class="line">  beta = <span class="number">0.5</span></span><br><span class="line">  mm = param[keylength][<span class="string">&#x27;m&#x27;</span>]</span><br><span class="line">  tt = param[keylength][<span class="string">&#x27;t&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  XX = int((<span class="number">2</span>*pow(N, beta)) / M_prime)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Bruteforce until p, q are found</span></span><br><span class="line">  a_prime = floor(c_prime/<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">while</span> a_prime &lt; top:</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Construct polynomial</span></span><br><span class="line">      m_inv = int(inverse_mod(M_prime, N))</span><br><span class="line">      k_tmp = int(pow(<span class="number">65537</span>, a_prime, M_prime))</span><br><span class="line">      known_part_pol = int(k_tmp * m_inv)</span><br><span class="line">      F = PolynomialRing(Zmod(N), implementation=<span class="string">&#x27;NTL&#x27;</span>, names=(<span class="string">&#x27;x&#x27;</span>,))</span><br><span class="line">      (x,) = F._first_ngens(<span class="number">1</span>)</span><br><span class="line">      pol = x + known_part_pol</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Get roots of polynomial using coppersmith</span></span><br><span class="line">      roots = coppersmith_howgrave_univariate(pol, N, beta, mm, tt, XX)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Check if roots are p, q</span></span><br><span class="line">      <span class="keyword">for</span> root <span class="keyword">in</span> roots:</span><br><span class="line">        factor1 = k_tmp + abs(root) * M_prime</span><br><span class="line">        <span class="keyword">if</span> mod(N, factor1) == <span class="number">0</span>:</span><br><span class="line">          factor2 = N // factor1</span><br><span class="line">          <span class="keyword">return</span> int(factor1), int(factor2)</span><br><span class="line">      a_prime += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#N = p*q</span></span><br><span class="line">N=<span class="number">15518961041625074876182404585394098781487141059285455927024321276783831122168745076359780343078011216480587575072479784829258678691739</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;[+] Factoring %i&quot;</span> % N)</span><br><span class="line"></span><br><span class="line">factor1, factor2 = roca(N)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;[+] Found factors of N:&quot;</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;[+] p =&quot;</span> , factor1)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;[+] q =&quot;</span> , factor2)</span><br></pre></td></tr></table></figure>
<h2 id="公钥指数e相关攻击"><a href="#公钥指数e相关攻击" class="headerlink" title="公钥指数e相关攻击"></a>公钥指数e相关攻击</h2><h3 id="e很小且明文m比较小"><a href="#e很小且明文m比较小" class="headerlink" title="e很小且明文m比较小"></a>e很小且明文m比较小</h3><p>以 e = 3 为例</p>
<p>m 较小的情况下，从小到大枚举 k，依次开 e 次方根，直到开出整数为止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">  res = gmpy2.iroot(c + i * n, <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">if</span>(res[<span class="number">1</span>] == <span class="literal">True</span>):</span><br><span class="line">     m = res[<span class="number">0</span>]</span><br><span class="line">     print(binascii.unhexlify(hex(m)[<span class="number">2</span>:].strip(<span class="string">&quot;L&quot;</span>)))</span><br><span class="line">     <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">&quot;i=&quot;</span> + str(i)</span><br><span class="line">  i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="e与模数N的一个或多个素数因子的欧拉函数不互素"><a href="#e与模数N的一个或多个素数因子的欧拉函数不互素" class="headerlink" title="e与模数N的一个或多个素数因子的欧拉函数不互素"></a>e与模数N的一个或多个素数因子的欧拉函数不互素</h3><p>N 可以直接分解，但由于 e 与一个或多个素数因子的欧拉函数不互素，而 e <em> d - k </em> phi(N) = 1 有解的充要条件是 gcd(e, phi(N)) = 1，因此无法直接通过扩展欧几里德算法求模反元素 d。</p>
<p><strong>e=2，Rabin加密解密算法</strong></p>
<p>破解 RSA 的关键即在于大整数的分解，只要 n 被成功分解，就能够破译。而 Rabin 密码体制是对 RSA 的一种修正。</p>
<ol>
<li>Rabin 密码体制对于同一密文，可能有两个以上对应的明文</li>
<li>破译该密码体制同样等价于对大整数的分解，RSA 中选取的公钥 e 满足 $1&lt;e&lt;\varphi(n)$</li>
<li>，而 Rabin 中则选取 e = 2</li>
</ol>
<p>密钥的产生:</p>
<ol>
<li><p>随机选择两个大素数 p，q，通常选取 p，q $\equiv 3(mod \quad4)$</p>
</li>
<li><p>密钥为<code>p</code>，<code>q</code></p>
</li>
<li><p>公钥<code>n=p*q</code></p>
</li>
<li><p>明文：<code>m</code>，密文：<code>c</code></p>
</li>
<li><p>加密：$c \equiv m^2 \quad mod \quad n$</p>
</li>
<li><p>解密过程如下：</p>
<ol>
<li><p>$m_p=c^{\frac{p+1}{4}}mod \quad p$</p>
<p>$m_q=c^{\frac{q+1}{4}}mod \quad q$</p>
</li>
<li><p>使用扩展欧几里得算法得到 $y_p\space和\space y_q$ ，使得 $y_p·p+y_q·q=1$</p>
</li>
<li><p>利用中国剩余定理得到</p>
<p>$x_1=(y_p·p·m_q+y_q·q·m_p) mod \quad n$</p>
<p>$x_2=n-x_1$</p>
<p>$x_3=(y_p·p·m_q-y_q·q·m_p) mod \quad n$</p>
<p>$x_4=n-x_3$</p>
<p>明文为该四个数中的一个。</p>
</li>
</ol>
</li>
</ol>
<p>解密脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">n2s</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hex(x)[<span class="number">2</span>:].decode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line"></span><br><span class="line">c = </span><br><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">n = p*q</span><br><span class="line">c_p = pow(c,(p+<span class="number">1</span>)/<span class="number">4</span>,p)</span><br><span class="line">c_q = pow(c,(q+<span class="number">1</span>)/<span class="number">4</span>,q)</span><br><span class="line">a = gmpy2.invert(p,q)</span><br><span class="line">b = gmpy2.invert(q,p)</span><br><span class="line">x = (b*q*c_p+a*p*c_q)%n</span><br><span class="line">y = (b*q*c_p-a*p*c_q)%n</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> n2s(x)</span><br><span class="line"><span class="keyword">print</span> n2s(n-x)</span><br><span class="line"><span class="keyword">print</span> n2s(y)</span><br><span class="line"><span class="keyword">print</span> n2s(n-y)</span><br></pre></td></tr></table></figure>
<p><strong>e=prime * 2^k，</strong><a target="_blank" rel="noopener" href="https://github.com/p4-team/ctf/tree/master/2015-10-18-hitcon/crypto_314_rsabin">Rsabin</a><strong>（hitcon-2015）</strong></p>
<p><strong>素数因子较小，<a target="_blank" rel="noopener" href="https://gist.github.com/elliptic-shiho/98bb452dc14e8c40e403">RSA?</a>（0ctf-2016）</strong></p>
<p>通过以下工具计算：x^e = c mod p 可能的根 x，即为明文 m 对素数因子 p 的余数，依次求出 m 对所有素数因子的余数，再利用中国剩余定理 CRT 即可求得明文 m。</p>
<p><strong>两组e与各自的N的欧拉函数均不互素，</strong><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/3314#toc-6">AzureRSA</a><strong>（高校运维赛eis-2018）</strong></p>
<p>已知：两组N不互素，通过gcd可以求得共同素数因子p，进而求得q1，q2。由于：</p>
<p>$gmpy2.gcd(e1, (p-1))=14$ </p>
<p>$gmpy2.gcd(e1, (q1-1)) = 2 $</p>
<p>$gmpy2.gcd(e2, (p-1)) = 14 $</p>
<p>$gmpy2.gcd(e2, (q2-1)) = 2$</p>
<p>因此，可以利用 q1，q2，求得：m^2 对于 q1，q2 的模，进而通过中国剩余定理CRT求得 m^2 对于 q1 * q2 的模，由于所求的值刚好可以开平方，否则需要通过 Rabin 解密法求明文m：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dq1 = gmpy2.invert(e1/<span class="number">2</span>, q1 - <span class="number">1</span>)</span><br><span class="line">dq2 = gmpy2.invert(e2/<span class="number">2</span>, q2 - <span class="number">1</span>)</span><br><span class="line">cq1 = gmpy2.powmod(c1, dq1, q1)</span><br><span class="line">cq2 = gmpy2.powmod(c2, dq2, q2)</span><br><span class="line">m2 = libnum.solve_crt([cq1, cq2], [q1, q2])</span><br><span class="line">m = gmpy2.iroot(m2, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> m[<span class="number">1</span>]: <span class="comment"># if not True, need to use Rabin to cal m</span></span><br><span class="line">  <span class="keyword">print</span> libnum.n2s(m[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="e-3，模数N相同，且明文存在线性关系m1-a-m2-b-mod-N"><a href="#e-3，模数N相同，且明文存在线性关系m1-a-m2-b-mod-N" class="headerlink" title="e=3，模数N相同，且明文存在线性关系m1=a*m2+b mod N"></a>e=3，模数N相同，且明文存在线性关系m1=a*m2+b mod N</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getM2</span>(<span class="params">a, b, c1, c2, n</span>):</span></span><br><span class="line">    a3 = pow(a,<span class="number">3</span>,n)</span><br><span class="line">    b3 = pow(b,<span class="number">3</span>,n)</span><br><span class="line">    first = c1 - a3 * c2 + <span class="number">2</span> * b3</span><br><span class="line">    first = first % n</span><br><span class="line">    second = <span class="number">3</span> * b * (a3 * c2 - b3)</span><br><span class="line">    second = second % n</span><br><span class="line">    third = second * gmpy2.invert(first, n)</span><br><span class="line">    third = third % n</span><br><span class="line">    fourth = (third + b) * gmpy2.invert(a,n)</span><br><span class="line">    <span class="keyword">return</span> fourth % n</span><br><span class="line">m = getM2(a, b, c1, c2, n) - padding2</span><br><span class="line"><span class="keyword">print</span> libnum.n2s(m)</span><br></pre></td></tr></table></figure>
<p>e 不为 3 时，利用 Coppersmith’s short-pad attack，即 padding 过短引起的攻击:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/FranklinReiter.sage">https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/FranklinReiter.sage</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">franklinReiter</span>(<span class="params">n,e,r,c1,c2</span>):</span></span><br><span class="line">    R.&lt;X&gt; = Zmod(n)[]</span><br><span class="line">    f1 = X^e - c1</span><br><span class="line">    f2 = (X + r)^e - c2</span><br><span class="line">    <span class="keyword">return</span> Integer(n-(compositeModulusGCD(f1,f2)).coefficients()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compositeModulusGCD</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> a.monic()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> compositeModulusGCD(b, a % b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CoppersmithShortPadAttack</span>(<span class="params">e,n,C1,C2,eps=<span class="number">1</span>/<span class="number">30</span></span>):</span></span><br><span class="line">    <span class="keyword">import</span> binascii</span><br><span class="line">    P.&lt;x,y&gt; = PolynomialRing(ZZ)</span><br><span class="line">    ZmodN = Zmod(n)</span><br><span class="line">    g1 = x^e - C1</span><br><span class="line">    g2 = (x+y)^e - C2</span><br><span class="line">    res = g1.resultant(g2)</span><br><span class="line">    P.&lt;y&gt; = PolynomialRing(ZmodN)</span><br><span class="line">    rres = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res.coefficients())):</span><br><span class="line">        rres += res.coefficients()[i]*(y^(res.exponents()[i][<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    diff = rres.small_roots(epsilon=eps)</span><br><span class="line">    recoveredM1 = franklinReiter(n,e,diff[<span class="number">0</span>],C1,C2)</span><br><span class="line">    print(recoveredM1)</span><br><span class="line">    print(<span class="string">&quot;Message is the following hex, but potentially missing some zeroes in the binary from the right end&quot;</span>)</span><br><span class="line">    print(hex(recoveredM1))</span><br><span class="line">    print(<span class="string">&quot;Message is one of:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        msg = hex(Integer(recoveredM1*pow(<span class="number">2</span>,i)))</span><br><span class="line">        <span class="keyword">if</span>(len(msg)%<span class="number">2</span> == <span class="number">1</span>):</span><br><span class="line">            msg = <span class="string">&#x27;0&#x27;</span> + msg</span><br><span class="line">        <span class="keyword">if</span>(msg[:<span class="number">2</span>]==<span class="string">&#x27;0x&#x27;</span>):</span><br><span class="line">            msg = msg[:<span class="number">2</span>]</span><br><span class="line">        print(binascii.unhexlify(msg))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testCoppersmithShortPadAttack</span>(<span class="params">eps=<span class="number">1</span>/<span class="number">25</span></span>):</span></span><br><span class="line">    <span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">import</span> binascii</span><br><span class="line">    M = <span class="string">&quot;flag&#123;This_Msg_Is_2_1337&#125;&quot;</span></span><br><span class="line">    M = int(binascii.hexlify(M),<span class="number">16</span>)</span><br><span class="line">    e = <span class="number">3</span></span><br><span class="line">    nBitSize =  <span class="number">8192</span></span><br><span class="line">    key = RSA.generate(nBitSize)</span><br><span class="line">    m = int(math.floor(nBitSize/(e*e))) - <span class="number">400</span></span><br><span class="line">    <span class="keyword">assert</span> (m &lt; nBitSize - len(bin(M)[<span class="number">2</span>:]))</span><br><span class="line">    r1 = random.randint(<span class="number">1</span>,pow(<span class="number">2</span>,m))</span><br><span class="line">    r2 = random.randint(r1,pow(<span class="number">2</span>,m))</span><br><span class="line">    M1 = pow(<span class="number">2</span>,m)*M + r1</span><br><span class="line">    M2 = pow(<span class="number">2</span>,m)*M + r2</span><br><span class="line">    C1 = Integer(pow(M1,e,key.n))</span><br><span class="line">    C2 = Integer(pow(M2,e,key.n))</span><br><span class="line">    CoppersmithShortPadAttack(e,key.n,C1,C2,eps)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFranklinReiter</span>():</span></span><br><span class="line">    p = random_prime(<span class="number">2</span>^<span class="number">512</span>)</span><br><span class="line">    q = random_prime(<span class="number">2</span>^<span class="number">512</span>)</span><br><span class="line">    n = p * q </span><br><span class="line">    e = <span class="number">11</span></span><br><span class="line">    m = randint(<span class="number">0</span>, n) </span><br><span class="line">    r = randint(<span class="number">0</span>, n) </span><br><span class="line">    c1 = pow(m + <span class="number">0</span>, e, n)</span><br><span class="line">    c2 = pow(m + r, e, n)</span><br><span class="line">    print(m)</span><br><span class="line">    recoveredM = franklinReiter(n,e,r,c1,c2)</span><br><span class="line">    print(recoveredM)</span><br><span class="line">    <span class="keyword">assert</span> recoveredM==m</span><br><span class="line">    print(<span class="string">&quot;They are equal!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="Wiener-attack"><a href="#Wiener-attack" class="headerlink" title="Wiener_attack"></a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Wiener&#39;s_attack">Wiener_attack</a></h3><p>假如 p 大于 q 而小于 2q（这是一个很经常的情况）而 $d \lt \frac{1}{3} × N ^{\frac{1}{4}} $，那么从 N 和 e 可以很有效地推算出 d。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">continued_fractions_expansion</span>(<span class="params">numerator,denominator</span>):</span><span class="comment">#(e,N)</span></span><br><span class="line">	result=[] </span><br><span class="line">	divident = numerator % denominator</span><br><span class="line">	quotient = numerator / denominator</span><br><span class="line">	result.append(quotient) </span><br><span class="line">	<span class="keyword">while</span> divident != <span class="number">0</span>:</span><br><span class="line">		numerator = numerator - quotient * denominator </span><br><span class="line">		tmp = denominator</span><br><span class="line">		denominator = numerator</span><br><span class="line">		numerator = tmp</span><br><span class="line">		divident = numerator % denominator</span><br><span class="line">		quotient = numerator / denominator</span><br><span class="line">		result.append(quotient) </span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convergents</span>(<span class="params">expansion</span>):</span></span><br><span class="line">	convergents=[(expansion[<span class="number">0</span>], <span class="number">1</span>)]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(expansion)):</span><br><span class="line">		numerator = <span class="number">1</span></span><br><span class="line">		denominator = expansion[i]</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">			numerator += expansion[j] * denominator</span><br><span class="line">			<span class="keyword">if</span> j==<span class="number">0</span>:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			tmp = denominator</span><br><span class="line">			denominator = numerator</span><br><span class="line">			numerator = tmp</span><br><span class="line">		convergents.append((numerator, denominator)) <span class="comment">#(k,d)</span></span><br><span class="line">	<span class="keyword">return</span> convergents</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newtonSqrt</span>(<span class="params">n</span>):</span></span><br><span class="line">	approx = n / <span class="number">2</span></span><br><span class="line">	better = (approx + n / approx) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">while</span> better != approx:</span><br><span class="line">	    approx = better</span><br><span class="line">	    better = (approx + n / approx) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> approx</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wiener_attack</span>(<span class="params">cons, e, N</span>):</span></span><br><span class="line">	<span class="keyword">for</span> cs <span class="keyword">in</span> cons:</span><br><span class="line">		k,d = cs</span><br><span class="line">		<span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		phi_N = (e * d - <span class="number">1</span>) / k</span><br><span class="line">		a = <span class="number">1</span></span><br><span class="line">		b = -((N - phi_N) + <span class="number">1</span>)</span><br><span class="line">		c = N</span><br><span class="line">		delta = b * b - <span class="number">4</span> * a * c</span><br><span class="line">		<span class="keyword">if</span> delta &lt;= <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		x1 = (newtonSqrt(delta) - b)/(<span class="number">2</span> * a)</span><br><span class="line">		x2 = -(newtonSqrt(delta) + b)/(<span class="number">2</span> * a)</span><br><span class="line">		<span class="keyword">if</span> x1 * x2 == N:</span><br><span class="line">			<span class="keyword">return</span> [x1, x2, k, d]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line">    c = </span><br><span class="line">    expansion = continued_fractions_expansion(e, n)</span><br><span class="line">    cons = convergents(expansion)</span><br><span class="line">    p, q, k, d = wiener_attack(cons, e, n)</span><br><span class="line">    m = pow(c, d, n)</span><br><span class="line">    print(libnum.n2s(m))</span><br></pre></td></tr></table></figure>
<h3 id="Boneh-and-Durfee-attack"><a href="#Boneh-and-Durfee-attack" class="headerlink" title="Boneh and Durfee attack"></a><a target="_blank" rel="noopener" href="https://github.com/mimoo/RSA-and-LLL-attacks">Boneh and Durfee attack</a></h3><p>d 过大，$d \gt \frac{1}{3} × N ^{\frac{1}{4}} $<br>那么可以尝试Boneh and Durfee attack</p>
<h3 id="低加密指数广播攻击"><a href="#低加密指数广播攻击" class="headerlink" title="低加密指数广播攻击"></a>低加密指数广播攻击</h3><p>以 e = 3 为例，3组不同的模数 N1，N2，N3 互素（如果不互素，可以通过欧几里德算法求最大公约数直接得到 p），则有：</p>
<p>C1 = me mod n1</p>
<p>C2 = me mod n2</p>
<p>C3 = me mod n3</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii,gmpy2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CRT</span>(<span class="params">mi, ai</span>):</span></span><br><span class="line">    <span class="keyword">assert</span>(reduce(gmpy2.gcd,mi)==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> (isinstance(mi, list) <span class="keyword">and</span> isinstance(ai, list))</span><br><span class="line">    M = reduce(<span class="keyword">lambda</span> x, y: x * y, mi)</span><br><span class="line">    ai_ti_Mi = [a * (M / m) * gmpy2.invert(M / m, m) <span class="keyword">for</span> (m, a) <span class="keyword">in</span> zip(mi, ai)]</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x + y, ai_ti_Mi) % M</span><br><span class="line">    </span><br><span class="line">e=<span class="number">0x3</span></span><br><span class="line">m=gmpy2.iroot(CRT(n, c), e)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="e非素数"><a href="#e非素数" class="headerlink" title="e非素数"></a>e非素数</h3><ul>
<li><p>e 非素数，e 和 phi 不互素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e &#x3D; 12</span><br><span class="line">p &#x3D; 58380004430307803367806996460773123603790305789098384488952056206615768274527</span><br><span class="line">q &#x3D; 81859526975720060649380098193671612801200505029127076539457680155487669622867</span><br><span class="line">ciphertext &#x3D; 206087215323690202467878926681944491769659156726458690815919286163630886447291570510196171585626143608988384615185921752409380788006476576337410136447460</span><br><span class="line"></span><br><span class="line">算出的m转化成字符串</span><br></pre></td></tr></table></figure>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = <span class="number">12</span></span><br><span class="line">p = <span class="number">58380004430307803367806996460773123603790305789098384488952056206615768274527</span></span><br><span class="line">q = <span class="number">81859526975720060649380098193671612801200505029127076539457680155487669622867</span></span><br><span class="line">n=p*q</span><br><span class="line">c = <span class="number">206087215323690202467878926681944491769659156726458690815919286163630886447291570510196171585626143608988384615185921752409380788006476576337410136447460</span></span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d4 = libnum.invmod(<span class="number">3</span>,phi)</span><br><span class="line">m4 = pow(c,d4,n)</span><br><span class="line"><span class="keyword">print</span> m4</span><br><span class="line">m = gmpy2.iroot(m4,<span class="number">4</span>)[<span class="number">0</span>]</span><br><span class="line">print(m)</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
</li>
<li><p>e1 和 e2 不互素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">e1:<span class="number">0x33240</span></span><br><span class="line"></span><br><span class="line">e2:<span class="number">0x3e4f</span></span><br><span class="line"></span><br><span class="line">n:<span class="number">0x9439682bf1b4ab48c43c524778c579cc844b60872275725c1dc893b5bcb358b9f136e4dab2a06318bb0c80e202a14bc54ea334519bec023934e01e9378abf329893f3870979e9f2f2be8fff4df931216a77007a2509f49f697bf286285e97fac5dc6e4a164b5c2cc430887b18136437ba67777bda05aafdeaf918221c812b4c7d1665238f84ab0fab7a77fcae92a0596e58343be7a8e6e75a5017c63a67eb11964970659cd6110e9ec6502288e9e443d86229ef2364dfecb63e2d90993a75356854eb874797340eece1b19974e86bee07019610467d44ec595e04af02b574a97fa98bdb2e779871c804219cab715f4a80fef7f8fb52251d86077560b39c1c2a1</span></span><br><span class="line"></span><br><span class="line">c1:<span class="number">0x7c7f315a3ebbe305c1ad8bd2f73b1bb8e300912b6b8ba1b331ac2419d3da5a9a605fd62915c11f8921c450525d2efda7d48f1e503041498f4f0676760b43c770ff2968bd942c7ef95e401dd7facbd4e5404a0ed3ad96ae505f87c4e12439a2da636f047d84b1256c0e363f63373732cbaf24bda22d931d001dcca124f5a19f9e28608ebd90161e728b782eb67deeba4cc81b6df4e7ee29a156f51a0e5148618c6e81c31a91036c982debd1897e6f3c1e5e248789c933a4bf30d0721a18ab8708d827858b77c1a020764550a7fe2ebd48b6848d9c4d211fd853b7a02a859fa0c72160675d832c94e0e43355363a2166b3d41b8137100c18841e34ff52786867d</span></span><br><span class="line"></span><br><span class="line">c2:<span class="number">0xf3a8b9b739196ba270c8896bd3806e9907fca2592d28385ef24afadc2a408b7942214dad5b9e14808ab988fb15fbd93e725edcc0509ab0dd1656557019ae93c38031d2a7c84895ee3da1150eda04cd2815ee3debaa7c2651b62639f785f6cabf83f93bf3cce7778ab369631ea6145438c3cd4d93d6f2759be3cc187651a33b3cc4c3b477604477143c32dfff62461fdfd9f8aa879257489bbf977417ce0fbe89e3f2464475624aafef57dd9ea60339793c69b53ca71d745d626f45e6a7beb9fcbd9d1a259433d36139345b7bb4f392e78f1b5be0d2c56ad50767ee851fac670946356b3c05d0605bf243b89c7e683cc75030b71633632fb95c84075201352d6</span></span><br><span class="line"></span><br><span class="line">c1=pow(m, e1, n)</span><br><span class="line">c2=pow(m, e2, n)</span><br></pre></td></tr></table></figure>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s1, s2, tmp = libnum.xgcd(e1, e2)</span><br><span class="line"><span class="keyword">if</span> s1 &lt; <span class="number">0</span>:</span><br><span class="line">    s1 = - s1</span><br><span class="line">    c1 = gmpy2.invert(c1, n)</span><br><span class="line"><span class="keyword">elif</span> s2 &lt; <span class="number">0</span>:</span><br><span class="line">    s2 = - s2</span><br><span class="line">    c2 = gmpy2.invert(c2, n)</span><br><span class="line">m = pow(c1, s1, n) * pow(c2, s2, n) % n</span><br><span class="line">m = <span class="number">211655262573966881062823795220179644607412162371069</span></span><br><span class="line"><span class="keyword">print</span> gmpy.root(m,<span class="number">3</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Coppersmith相关攻击"><a href="#Coppersmith相关攻击" class="headerlink" title="Coppersmith相关攻击"></a>Coppersmith相关攻击</h2><p>Coppersmith定理指出在一个 e 阶的 mod n 多项式 f(x) 中，如果有一个根小于 n^1/e，就可以运用一个 O(log n) 的算法求出这些根。</p>
<h3 id="Coppersmith’s-short-pad-attack"><a href="#Coppersmith’s-short-pad-attack" class="headerlink" title="Coppersmith’s short-pad attack"></a><a target="_blank" rel="noopener" href="https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/FranklinReiter.sage">Coppersmith’s short-pad attack</a></h3><p>明文padding长度太短，小于 $floor(nBitSize/(e^2))$</p>
<h3 id="Hastad’s-Broadcast-Attack-with-Linear-Padding"><a href="#Hastad’s-Broadcast-Attack-with-Linear-Padding" class="headerlink" title="Hastad’s Broadcast Attack with Linear Padding"></a><a target="_blank" rel="noopener" href="https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/hastads.sage">Hastad’s Broadcast Attack with Linear Padding</a></h3><p>相同 e，e 组不同模数 N 加密明文 m 的线性关系，</p>
<p>$cArray[i] = pow(aArray[i]*msg + bArray[i],e,nArray[i])$</p>
<p>当 aArray[i] = 1，bArray[i] = 0 时，即为低加密指数广播攻击。</p>
<h3 id="Stereotyped-messages攻击"><a href="#Stereotyped-messages攻击" class="headerlink" title="Stereotyped messages攻击"></a>Stereotyped messages攻击</h3><p>至少已知明文 m 的 ceil(nBitSize*(1-1.0/e)) 位，即知道明文的高位。</p>
<p>如：N.bit_length() = 2048，e = 3，则至少需要已知：$ceil(2048*(1-1.0/3)) = 1366$位明文</p>
<p>$pol = ((message + ZmodN((pow(2,unknownEndBitIndex)))*x)^e) - c$</p>
<p>当 unknownEndBitIndex = 0 时，即为明文最后字符未知的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">0x3</span></span><br><span class="line">b=<span class="number">0x666c6167206973203a746573743132313131313131313131313133343536000000000000000000</span></span><br><span class="line">n = <span class="number">0xf85539597ee444f3fcad07142ecf6eaae5320301244a7cedc50b2beed7e60ffa11ccf28c1a590fb81346fb16b0cecd046a1f63f0bf93185c109b8c93068ec02f</span></span><br><span class="line">c=<span class="number">0xa75c3c8a19ed9c911d851917e442a8e7b425e4b7f92205ca532a2ab0f5abe6cb86d164cc61374877f9e88e7bca606b43c79f1d59deadfcc68c3db52e5fc42f0</span></span><br><span class="line">kbits=<span class="number">72</span> <span class="comment">#未知低位位数</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = (x + b) ^ e - c</span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;x: %s&quot;</span> %hex(int(x0))</span><br></pre></td></tr></table></figure>
<h3 id="Partial-Key-Exposure-Attack"><a href="#Partial-Key-Exposure-Attack" class="headerlink" title="Partial Key Exposure Attack"></a>Partial Key Exposure Attack</h3><p>已知密钥 d 的低位 d0，d0 位数大于 nBitSize / 4。</p>
<p>sage 脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_p</span>(<span class="params">p0, kbits, n</span>):</span></span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    nbits = n.nbits()</span><br><span class="line">    f = <span class="number">2</span>^kbits*x + p0</span><br><span class="line">    f = f.monic()</span><br><span class="line">    roots = f.small_roots(X=<span class="number">2</span>^(nbits//<span class="number">2</span>-kbits), beta=<span class="number">0.3</span>)  <span class="comment"># find root &lt; 2^(nbits//2-kbits) with factor &gt;= n^0.3</span></span><br><span class="line">    <span class="keyword">if</span> roots:</span><br><span class="line">        x0 = roots[<span class="number">0</span>]</span><br><span class="line">        p = gcd(<span class="number">2</span>^kbits*x0 + p0, n)</span><br><span class="line">        <span class="keyword">return</span> ZZ(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_p</span>(<span class="params">d0, kbits, e, n</span>):</span></span><br><span class="line">    X = var(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">1</span>, e+<span class="number">1</span>):</span><br><span class="line">        results = solve_mod([e*d0*X - k*X*(n-X+<span class="number">1</span>) + k*n == X], <span class="number">2</span>^kbits)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> results:</span><br><span class="line">            p0 = ZZ(x[<span class="number">0</span>])</span><br><span class="line">            p = partial_p(p0, kbits, n)</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n =<span class="number">0x56a8f8cbc72ff68e67c72718bd16d7e98150aea08780f6c4f532d20ca3c92a0fb07c959e008cbcbeac744854bc4203eb9b2996e9cf630133bc38952a2c17c27d</span> </span><br><span class="line">    e = <span class="number">0x3</span></span><br><span class="line">    d = <span class="number">0x594b6c9631c4987f588399f22466b51fc48ed449b8aae0309b5736ef0b741893</span></span><br><span class="line">    beta = <span class="number">0.5</span></span><br><span class="line">    epsilon = beta^<span class="number">2</span>/<span class="number">7</span></span><br><span class="line"></span><br><span class="line">    nbits = n.nbits()</span><br><span class="line">    kbits = <span class="number">255</span></span><br><span class="line">    d0 = d &amp; (<span class="number">2</span>^kbits<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;lower %d bits (of %d bits) is given&quot;</span> % (kbits, nbits)</span><br><span class="line"></span><br><span class="line">    p = find_p(d0, kbits, e, n)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;found p: %d&quot;</span> % p</span><br><span class="line">    q = n//p</span><br><span class="line">    <span class="keyword">print</span> hex(d)</span><br><span class="line">    <span class="keyword">print</span> hex(inverse_mod(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="Partial-Key-Recovery-Attack"><a href="#Partial-Key-Recovery-Attack" class="headerlink" title="Partial Key Recovery Attack"></a><a target="_blank" rel="noopener" href="https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/RSATool.py">Partial Key Recovery Attack</a></h3><p>已知密钥 d 的低位 d0，d0 位数大于 nBitSize / 2</p>
<h3 id="Factoring-with-high-bits-known攻击"><a href="#Factoring-with-high-bits-known攻击" class="headerlink" title="Factoring with high bits known攻击"></a>Factoring with high bits known攻击</h3><p>题目给出p的高位，给出n，e，c</p>
<p>该后门算法依赖于Coppersmith partial information attack算法, sage实现该算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">0xd7e990dec6585656512c841ac932edaf048184bac5ebf9967000000000000000</span></span><br><span class="line">n = <span class="number">0xb50193dc86a450971312d72cc8794a1d3f4977bcd1584a20c31350ac70365644074c0fb50b090f38d39beb366babd784d6555d6de3be54dad3e87a93a703abdd</span></span><br><span class="line"></span><br><span class="line">kbits = <span class="number">60</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x + p</span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;x: %s&quot;</span> %hex(int(x0))</span><br><span class="line">p = p+x0</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;p: &quot;</span>, hex(int(p))</span><br><span class="line"><span class="keyword">assert</span> n % p == <span class="number">0</span></span><br><span class="line">q = n/int(p)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;q: &quot;</span>, hex(int(q))</span><br><span class="line"><span class="comment">#其中kbit是未知的p的低位位数</span></span><br><span class="line"><span class="comment">#x0为求出来的p低位</span></span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="其他条件相关攻击"><a href="#其他条件相关攻击" class="headerlink" title="其他条件相关攻击"></a>其他条件相关攻击</h2><h3 id="已知p，q其他等式"><a href="#已知p，q其他等式" class="headerlink" title="已知p，q其他等式"></a>已知p，q其他等式</h3><p>已知 p + q = s，根据一元二次方程：a = 1，b = -s，c = N，可解得：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = long((-b + gmpy2.isqrt(b ** <span class="number">2</span> - <span class="number">4</span>*a*c))/<span class="number">2L</span>) </span><br></pre></td></tr></table></figure>
<h3 id="dp-amp-dq泄露"><a href="#dp-amp-dq泄露" class="headerlink" title="dp&amp;dq泄露"></a>dp&amp;dq泄露</h3><p>$dp = d \space mod \space(p - 1)$</p>
<p>$dq = d \space mod \space (q - 1)$</p>
<p>这种参数是为了让解密的时候更快速产生的(CRT)。</p>
<p>仅给出 p，q，dp，dq，c，不给公钥 e；</p>
<p>解密：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inv = gmpy2.invert(q, p)</span><br><span class="line">mp = pow(c,dp,p)</span><br><span class="line">mq = pow(c,dq,q)</span><br><span class="line">m = (((mp - mq) * inv) % p) * q + mq</span><br></pre></td></tr></table></figure>
<h3 id="dp泄露"><a href="#dp泄露" class="headerlink" title="dp泄露"></a>dp泄露</h3><p>给出公钥n,e以及dp</p>
<p>求解私钥d脚本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getd</span>(<span class="params">n,e,dp</span>):</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,e):</span><br><span class="line">     <span class="keyword">if</span> (dp*e<span class="number">-1</span>)%i == <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">if</span> n%(((dp*e<span class="number">-1</span>)/i)+<span class="number">1</span>)==<span class="number">0</span>:</span><br><span class="line">         p=((dp*e<span class="number">-1</span>)/i)+<span class="number">1</span></span><br><span class="line">         phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">         d = gmpy2.invert(e,phi)%phi</span><br><span class="line">         <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>
<h3 id="多素数因子"><a href="#多素数因子" class="headerlink" title="多素数因子"></a>多素数因子</h3><p>公钥 n 由多个素数因子组成。</p>
<p><a target="_blank" rel="noopener" href="https://www.alpertron.com.ar/ECM.HTM">分解整数网站</a></p>
<p>2020 国赛初赛的 RSA 要求分解 n 得到多个素因子，利用 fermat attack。（分解次数10e级别，额……）</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><ol>
<li><p>已知d其他等式，以2为明文，构造p的倍数，使之与N共模</p>
<p>已知：k = (p - r) * d，构造如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp &#x3D; pow(2, e * k + r - 1, n) - 1</span><br><span class="line">p &#x3D; libnum.gcd(tmp, n)</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 <code>pow(p + q, e1, N ), pow(p + e1, q, N)</code> 构造 p 的倍数，使之与 Ｎ 共模</p>
<p>$c_1 = pow(p + q, e_1, N ), c_2 =pow(p + e_1, q, N),已知c_1,c_2,e_1,N,求p,q$</p>
<ul>
<li><p>整理$c_1$</p>
<p>$c_1 =(p+q)^{e_1} \mod n$</p>
<p>$c_1=(p+q)^{e_1}-kpq$</p>
<p>$c_1 \mod q = (p \mod q + q \mod q)^{e_1} \mod q - (kpq \mod q)$</p>
<p>$c_1 = p^{e_1} \mod q$</p>
<p>$c1 = p^{e_1}-kq$</p>
</li>
<li><p>整理$c_2$</p>
<p>$c_2=(p+e_1)^q \mod N$</p>
<p>$c_2=(p+e_1)^q -kpq$</p>
<p>$c_2 \mod q = (p \mod q + e_1 \mod q)^q \mod q - (kpq \mod q)$</p>
<p>$其中p \mod q + e_1 \mod q =(p+e_1) \mod q ，且根据费马小定理，a^p ≡ a (\mod p)  ，得$</p>
<p>$c_2=(p+e_1) \mod q$</p>
<p>$c_2=p+e_1-kq$</p>
<p>$c_2-e_1=p-kq$</p>
</li>
<li><p>结合$c_1 、c_2$</p>
<p>$c1 = p^{e_1}-kq $   ①</p>
<p>$c_2-e_1=p-kq$</p>
<p>$(c_2-e_1)^{e_1}=p^{e_1}+…+(k-q)^{e_1}$   ②</p>
<p>② - ① =&gt; $(c_2-e_1)^{e_1}-c_1=tkq$</p>
<p>$有 pow((c_2-e_1),e_1,N)=(c_2-e_1)^{e_1}$</p>
<p>$所以：gcd(pow((c_2-e_1),e_1,N))-c_1,N)=q$</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = pow(c2 - e1, e1, N)</span><br><span class="line">q = gmpy2.gcd(k - c1, N)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="next-prime"><a href="#next-prime" class="headerlink" title="next_prime"></a>next_prime</h3><p>原理：根据素数定理，素数的平均间隔为：$x/π(x)≈lnx$，因此常见的下一个素数比当前素数大一点，一般不会超过1500。</p>
<p>可以用 yafu 分解。</p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_theory/#2018-pwnhub-lhy"><strong>LHY</strong></a></p>
<p>已知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; gmpy.next_prime(x ** 3 + y ** 3)</span><br><span class="line">q &#x3D; gmpy.next_prime(x ** 2 * y + y ** 2 * x)</span><br><span class="line">x &#x3D; 2 * y</span><br></pre></td></tr></table></figure>
<p>因此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; next_prime(9 * y ** 3) &#x3D; 9 * y ** 3 + a</span><br><span class="line">q &#x3D; next_prime(6 * y ** 3) &#x3D; 6 * y ** 3 + b</span><br></pre></td></tr></table></figure>
<p>根据素数定理，a，b 很小，因此 <code>n ≈ 54 * y ** 6</code>。可以通过以下方法求得 p：</p>
<ul>
<li><p>得知 y 的上界，而 y 的下界也不会离上界太远，可以利用二分查找法来寻找满足条件的 y，p 和 q</p>
</li>
<li><p>由于 a，b 很小，y 如果改变，y ^ 3 改变的值将远大于 a，b 的影响，因此可以认为 <code>y = iroot(y / 54,  6)</code>，进而爆破 a（从1到1500）求得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; next_prime(9 * y ** 3) &#x3D; (9 * y **3 + a) % n &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>，比直接求 next_prime 速度快些</p>
</li>
<li><p><code>p = 9 * y ** 3 + a</code>，由于 a，b 很小，可以认为 p 高位大部分 bit 已知，通过 Coppersmith 攻击可恢复不确定的低位。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">tmp = </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> gmpy2.iroot(tmp, <span class="number">2018</span>)</span><br><span class="line"><span class="keyword">print</span> gmpy2.iroot(tmp - <span class="number">1</span>, <span class="number">2018</span>)</span><br><span class="line"><span class="keyword">print</span> gmpy2.iroot(tmp - <span class="number">2</span>, <span class="number">2018</span>)</span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">y = </span><br><span class="line">y = gmpy2.next_prime(y)</span><br><span class="line"></span><br><span class="line">enc = </span><br><span class="line"></span><br><span class="line">end = gmpy2.iroot(n / <span class="number">54</span>, <span class="number">6</span>)[<span class="number">0</span>]</span><br><span class="line">beg = end - <span class="number">2000000</span></span><br><span class="line"></span><br><span class="line">mid = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> beg &lt; end:</span><br><span class="line">    mid = (beg + end) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> gmpy2.is_prime(mid) != <span class="number">1</span>:</span><br><span class="line">        mid = gmpy2.next_prime(mid)</span><br><span class="line">    p = gmpy2.next_prime(<span class="number">9</span> * mid**<span class="number">3</span>)</span><br><span class="line">    q = gmpy2.next_prime(<span class="number">6</span> * mid**<span class="number">3</span>)</span><br><span class="line">    n1 = p * q</span><br><span class="line">    <span class="keyword">if</span> n1 == n:</span><br><span class="line">        <span class="keyword">print</span> p, q</span><br><span class="line">        phin = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">        d = gmpy2.invert(<span class="number">0x10001</span>, phin)</span><br><span class="line">        m = gmpy2.powmod(enc, d, n)</span><br><span class="line">        <span class="keyword">print</span> hex(m)[<span class="number">2</span>:].strip(<span class="string">&#x27;L&#x27;</span>).decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> n1 &lt; n:</span><br><span class="line">        beg = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        end = mid</span><br><span class="line">    <span class="keyword">print</span> beg, end</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://bbs.ichunqiu.com/thread-36705-1-1.html">已知nextprime(p)*nexprime(q)的值</a></p>
<p>$npnq = nextprime(p)nextprime(q) = (p + x) (q + y)$</p>
<p>联立 $p * q = N$，得：</p>
<p>$yp^2 + (n + xy - npnq)p + x n = 0$</p>
<p>爆破 x 和 y（从1到1500）解一元二次方程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n = </span><br><span class="line">m = </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadratic</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    ga=gmpy2.mpz(a)</span><br><span class="line">    gb=gmpy2.mpz(b)</span><br><span class="line">    gc=gmpy2.mpz(c)</span><br><span class="line">    delta=gb**<span class="number">2</span><span class="number">-4</span>*ga*gc</span><br><span class="line">    <span class="keyword">if</span> delta&lt;=<span class="number">0</span> <span class="keyword">or</span> a==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    tmp=gmpy2.iroot(delta,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> tmp[<span class="number">1</span>]==<span class="literal">True</span>:</span><br><span class="line">        x1 = (-gb + tmp[<span class="number">0</span>]) / (<span class="number">2</span>*ga)</span><br><span class="line">        x2 = (-gb - tmp[<span class="number">0</span>]) / (<span class="number">2</span> * ga)</span><br><span class="line">        <span class="keyword">if</span> x1&gt;<span class="number">0</span> <span class="keyword">and</span> n%x1==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> x1</span><br><span class="line">            <span class="keyword">return</span> x1</span><br><span class="line">        <span class="keyword">if</span> x2&gt;<span class="number">0</span> <span class="keyword">and</span> n%x2==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> x2</span><br><span class="line">            <span class="keyword">return</span> x2</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1500</span>):</span><br><span class="line">        <span class="keyword">print</span> x</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1500</span>):</span><br><span class="line">            a=y</span><br><span class="line">            b=x * y - m + n</span><br><span class="line">            c=x * n</span><br><span class="line">            <span class="keyword">if</span> quadratic(a,b,c)!=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="LLL算法"><a href="#LLL算法" class="headerlink" title="LLL算法"></a>LLL算法</h3><p>通过三组 e 和 N（d 相同），我们可以将三组 e 和 N 进行基础矩阵的构造，使用 lattice 还原技术中的 LLL 可以求得该矩阵的最小基向量 b。</p>
<p>详细可见格密码。</p>
<p>实现参考论文：Factoring Polynomials with Rational Coefficients</p>
<p>sage 脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">e0=</span><br><span class="line">n0=</span><br><span class="line">c0=</span><br><span class="line">e1=</span><br><span class="line">n1=</span><br><span class="line">c1=</span><br><span class="line">e2=</span><br><span class="line">n2=</span><br><span class="line">c2=</span><br><span class="line">M1 = Matrix(<span class="number">4</span>,<span class="number">4</span>,<span class="number">0</span>)</span><br><span class="line">temp = int(n1)</span><br><span class="line">M = isqrt(max(n0,n1,n2))</span><br><span class="line">M1[<span class="number">0</span>,<span class="number">0</span>] = M</span><br><span class="line">M1[<span class="number">0</span>,<span class="number">1</span>] = e0</span><br><span class="line">M1[<span class="number">0</span>,<span class="number">2</span>] = e1</span><br><span class="line">M1[<span class="number">0</span>,<span class="number">3</span>] = e2</span><br><span class="line">M1[<span class="number">1</span>,<span class="number">1</span>] = -n0</span><br><span class="line">M1[<span class="number">2</span>,<span class="number">2</span>] = -n1</span><br><span class="line">M1[<span class="number">3</span>,<span class="number">3</span>] = -n2</span><br><span class="line">BL = M1.LLL()</span><br><span class="line"><span class="keyword">print</span> (BL)</span><br><span class="line">d = abs(BL[<span class="number">0</span>,<span class="number">0</span>])/M</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>
<p>题目：SCTF-RSA</p>
<h3 id="e-和-phi-n-不互素"><a href="#e-和-phi-n-不互素" class="headerlink" title="e 和 phi(n) 不互素"></a>e 和 phi(n) 不互素</h3><p>正常情况下的 RSA 都要求 e 和 phi(n) 要互素，不过也有一些 e 和 phi(n) 有很小的公约数的题目，这些题目基本都能通过计算 e 对 phi(n)的逆元 d 来求解。</p>
<p>然而当 e 和 p - 1 或 q - 1 的最大公约数就是 e 本身，也就是说 e | p - 1，需要对 c 开 e 次方根才行。</p>
<p>可以将同余方程</p>
<script type="math/tex; mode=display">
m^e \equiv c \quad (\text{mod}\ n)</script><p>化成</p>
<script type="math/tex; mode=display">
\begin{aligned}
m^e &\equiv c \quad (\text{mod}\ p)\newline
m^e &\equiv c \quad (\text{mod}\ q)
\end{aligned}</script><p>然后分别在 GF(p) 和 GF(q) 上对 c 开 e 次方根，再用 CRT 组合一下即可得到在 mod n 下的解。</p>
<p><strong>做法</strong></p>
<ul>
<li>先用 Adleman-Manders-Miller rth Root Extraction Method 在 GF(p) 和 GF(q) 上对 c 开 e 次根，分别得到一个解。</li>
<li>然后去找到所有的 e 个 primitive nth root of 1，乘以上面那个解，得到所有的 e 个解。</li>
<li>再用 CRT 对 GF(p) 和 GF(q) 上的两组 e 个解组合成 mod n 下的解，可以得到 e ^ 2 个 mod n 的解。最后能通过 check 的即为 flag。</li>
</ul>
<p>sage 脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def AMM(o, r, q):</span><br><span class="line">    start &#x3D; time.time()</span><br><span class="line">    print(&#39;\n----------------------------------------------------------------------------------&#39;)</span><br><span class="line">    print(&#39;Start to run Adleman-Manders-Miller Root Extraction Method&#39;)</span><br><span class="line">    print(&#39;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#39;.format(r, o, q))</span><br><span class="line">    g &#x3D; GF(q)</span><br><span class="line">    o &#x3D; g(o)</span><br><span class="line">    p &#x3D; g(random.randint(1, q))</span><br><span class="line">    while p ^ ((q-1) &#x2F;&#x2F; r) &#x3D;&#x3D; 1:</span><br><span class="line">        p &#x3D; g(random.randint(1, q))</span><br><span class="line">    print(&#39;[+] Find p:&#123;&#125;&#39;.format(p))</span><br><span class="line">    t &#x3D; 0</span><br><span class="line">    s &#x3D; q - 1</span><br><span class="line">    while s % r &#x3D;&#x3D; 0:</span><br><span class="line">        t +&#x3D; 1</span><br><span class="line">        s &#x3D; s &#x2F;&#x2F; r</span><br><span class="line">    print(&#39;[+] Find s:&#123;&#125;, t:&#123;&#125;&#39;.format(s, t))</span><br><span class="line">    k &#x3D; 1</span><br><span class="line">    while (k * s + 1) % r !&#x3D; 0:</span><br><span class="line">        k +&#x3D; 1</span><br><span class="line">    alp &#x3D; (k * s + 1) &#x2F;&#x2F; r</span><br><span class="line">    print(&#39;[+] Find alp:&#123;&#125;&#39;.format(alp))</span><br><span class="line">    a &#x3D; p ^ (r**(t-1) * s)</span><br><span class="line">    b &#x3D; o ^ (r*alp - 1)</span><br><span class="line">    c &#x3D; p ^ s</span><br><span class="line">    h &#x3D; 1</span><br><span class="line">    for i in range(1, t):</span><br><span class="line">        d &#x3D; b ^ (r^(t-1-i))</span><br><span class="line">        if d &#x3D;&#x3D; 1:</span><br><span class="line">            j &#x3D; 0</span><br><span class="line">        else:</span><br><span class="line">            print(&#39;[+] Calculating DLP...&#39;)</span><br><span class="line">            j &#x3D; - dicreat_log(a, d)</span><br><span class="line">            print(&#39;[+] Finish DLP...&#39;)</span><br><span class="line">        b &#x3D; b * (c^r)^j</span><br><span class="line">        h &#x3D; h * c^j</span><br><span class="line">        c &#x3D; c ^ r</span><br><span class="line">    result &#x3D; o^alp * h</span><br><span class="line">    end &#x3D; time.time()</span><br><span class="line">    print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start))</span><br><span class="line">    print(&#39;Find one solution: &#123;&#125;&#39;.format(result))</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">def findAllPRoot(p, e):</span><br><span class="line">    print(&quot;Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.&quot;.format(e, p))</span><br><span class="line">    start &#x3D; time.time()</span><br><span class="line">    proot &#x3D; set()</span><br><span class="line">    while len(proot) &lt; e:</span><br><span class="line">        proot.add(pow(random.randint(2, p-1), (p-1)&#x2F;&#x2F;e, p))</span><br><span class="line">    end &#x3D; time.time()</span><br><span class="line">    print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start))</span><br><span class="line">    return proot</span><br><span class="line"></span><br><span class="line">def findAllSolutions(mp, proot, cp, p):</span><br><span class="line">    print(&quot;Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.&quot;.format(e, cp, p))</span><br><span class="line">    start &#x3D; time.time()</span><br><span class="line">    all_mp &#x3D; set()</span><br><span class="line">    for root in proot:</span><br><span class="line">        mp2 &#x3D; mp * root % p</span><br><span class="line">        assert(pow(mp2, e, p) &#x3D;&#x3D; cp)</span><br><span class="line">        all_mp.add(mp2)</span><br><span class="line">    end &#x3D; time.time()</span><br><span class="line">    print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start))</span><br><span class="line">    return all_mp</span><br><span class="line"></span><br><span class="line">c &#x3D; </span><br><span class="line">p &#x3D; </span><br><span class="line">q &#x3D; </span><br><span class="line">e &#x3D;</span><br><span class="line">cp &#x3D; c % p</span><br><span class="line">cq &#x3D; c % q</span><br><span class="line">mp &#x3D; AMM(cp, e, p)</span><br><span class="line">mq &#x3D; AMM(cq, e, q)</span><br><span class="line">p_proot &#x3D; findAllPRoot(p, e)</span><br><span class="line">q_proot &#x3D; findAllPRoot(q, e)</span><br><span class="line">mps &#x3D; findAllSolutions(mp, p_proot, cp, p)</span><br><span class="line">mqs &#x3D; findAllSolutions(mq, q_proot, cq, q)</span><br><span class="line">print mps, mqs</span><br><span class="line"></span><br><span class="line">def check(m):</span><br><span class="line">    h &#x3D; m.hex()</span><br><span class="line">    if len(h) &amp; 1:</span><br><span class="line">        return False</span><br><span class="line">    if h.decode(&#39;hex&#39;).startswith(&#39;NCTF&#39;):</span><br><span class="line">        print(h.decode(&#39;hex&#39;))</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">print(&#39;Start CRT...&#39;)</span><br><span class="line">for mpp in mps:</span><br><span class="line">    for mqq in mqs:</span><br><span class="line">        solution &#x3D; CRT_list([int(mpp), int(mqq)], [p, q])</span><br><span class="line">        if check(solution):</span><br><span class="line">            print(solution)</span><br><span class="line">    print(time.time() - start)</span><br><span class="line"></span><br><span class="line">end &#x3D; time.time()</span><br><span class="line">print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start))</span><br></pre></td></tr></table></figure>
<h3 id="选择密文攻击"><a href="#选择密文攻击" class="headerlink" title="选择密文攻击"></a>选择密文攻击</h3><p>任意给定密文，系统返回明文，选择密文攻击。</p>
<p><a target="_blank" rel="noopener" href="http://skysec.top/2018/09/17/2018-noxCTF-Crypto-RSA/#Decryptor">Decryptor</a><strong>（noxCTF-2018）</strong></p>
<p>已知n，c，e，向服务器发送密文得到明文。</p>
<p>构造一个 x，使得：</p>
<p>$k \equiv x^ec \text{ } mod \text{ } n$</p>
<p>然后我们把 k 发送过去，得到：</p>
<p>$k^d \equiv (x^ec)^d \text{ } mod \text{ } n$</p>
<p>$ k^d \equiv xc^d \text{ } mod \text{ } n $</p>
<p>$ k^dx^-1 \equiv m \text{ } mod \text{ } n $</p>
<p>我们构造 x=2 即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = hex((pow(<span class="number">2</span>,e,N)*c)%N)[<span class="number">2</span>:<span class="number">-1</span>]</span><br><span class="line"><span class="comment">#put x</span></span><br><span class="line"><span class="comment">#get tmp</span></span><br><span class="line">libnum.n2s((tmp*gmpy2.invert(<span class="number">2</span>,N))%N)</span><br></pre></td></tr></table></figure>
<h3 id="LSB-Oracle-Attack"><a href="#LSB-Oracle-Attack" class="headerlink" title="LSB Oracle Attack"></a>LSB Oracle Attack</h3><p>适用情况：可以选择密文并泄露最低位。</p>
<p>在一次RSA加密中，明文为 m，模数为 n，加密指数为 e，密文为 c。</p>
<p>我们可以构造出 $c’=(2^ec) \mod n=(2^em^e) \mod n=(2m)^e \mod n$ </p>
<p>因为 m 的两倍可能大于 n，所以经过解密得到的明文是  $m’=(2m) \mod n $。</p>
<p>我们还能够知道 $m’ $的最低位lsb 是1还是0。<br>因为 n 是奇数，而 2m 是偶数，所以如果 lsb 是0，说明 (2m) % n  ​是偶数，没有超过 n，即 m &lt; n / 2.0，反之则 m &gt; n / 2.0 。<br>举个例子就能明白 2 % 3 = 2 是偶数，而 4 % 3 = 1 是奇数。<br>以此类推，构造密文 $c” = (4^ec) \space mod \space n ，使其解密后为 \space m” = (4m) \mod n$ ，判断 m” 的奇偶性可以知道 m 和 n / 4 的大小关系。<br>所以我们就有了一个二分算法，可以在对数时间内将m的范围逼近到一个足够狭窄的空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brute_flag</span>(<span class="params">encrypted_flag, n, e</span>):</span></span><br><span class="line"></span><br><span class="line">    flag_count = n_count = <span class="number">1</span></span><br><span class="line">    flag_lower_bound = <span class="number">0</span></span><br><span class="line">    flag_upper_bound = n</span><br><span class="line">    ciphertext = encrypted_flag</span><br><span class="line">    mult = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> flag_upper_bound &gt; flag_lower_bound + <span class="number">1</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;input your option:&quot;</span>)</span><br><span class="line">        sh.sendline(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">        ciphertext = (ciphertext * pow(<span class="number">2</span>, e, n)) % n</span><br><span class="line">        flag_count *= <span class="number">2</span></span><br><span class="line">        n_count = n_count * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">        print(<span class="string">&quot;bit = %d&quot;</span> % mult)</span><br><span class="line">        mult += <span class="number">1</span></span><br><span class="line">        sh.recvuntil(<span class="string">&quot;Your encrypted message:&quot;</span>)</span><br><span class="line">        sh.sendline(str(ciphertext))</span><br><span class="line">        data=sh.recvline()[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span>(data==<span class="string">&#x27;The plain of your decrypted message is even!&#x27;</span>):</span><br><span class="line">            flag_upper_bound = n * n_count / flag_count</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag_lower_bound = n * n_count / flag_count</span><br><span class="line">            n_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> flag_upper_bound</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Leonlist</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/09/21/CTF%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/">http://yoursite.com/2020/09/21/CTF%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RSA/">RSA</a><a class="post-meta__tags" href="/tags/CTF/">CTF</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2019/11/10/53eTB2uiNRlXwFP.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/22/BUUCTF%E5%88%B7%E9%A2%98-RSA/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2019/11/10/lP3rLNUBaGtSVzc.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">BUUCTF刷题-RSA</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/11/pwn%E5%85%A5%E9%97%A8-%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA/"><img class="next-cover" data-lazy-src="https://i.loli.net/2019/11/10/egVhFWopA5mP2Hk.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">pwn入门-花式栈溢出</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/09/22/BUUCTF刷题-RSA/" title="BUUCTF刷题-RSA"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2019/11/10/lP3rLNUBaGtSVzc.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-22</div><div class="relatedPosts_title">BUUCTF刷题-RSA</div></div></a></div><div class="relatedPosts_item"><a href="/2020/11/16/2020上海市大学生网络安全赛-Crypto/" title="2020上海市大学生网络安全赛-baby_rsa"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2019/11/10/rJbFpE65tmxPv7R.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-16</div><div class="relatedPosts_title">2020上海市大学生网络安全赛-baby_rsa</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/29/CTF密码学-ECC/" title="CTF密码学-ECC"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2019/11/10/53eTB2uiNRlXwFP.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-29</div><div class="relatedPosts_title">CTF密码学-ECC</div></div></a></div><div class="relatedPosts_item"><a href="/2020/10/05/CTF密码学-MT19937/" title="CTF密码学-MT19937"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2019/11/10/53eTB2uiNRlXwFP.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-05</div><div class="relatedPosts_title">CTF密码学-MT19937</div></div></a></div><div class="relatedPosts_item"><a href="/2020/10/05/CTF密码学-格密码/" title="CTF密码学-格密码"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2019/11/10/lP3rLNUBaGtSVzc.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-05</div><div class="relatedPosts_title">CTF密码学-格密码</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Leonlist</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>