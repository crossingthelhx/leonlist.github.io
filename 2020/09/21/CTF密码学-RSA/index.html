<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CTF密码学-RSA | Leonlist's Blog</title><meta name="description" content="公钥体制数学基础素数与互素数1.素数： 一个数如果除了1与它本身之外没有其他的因数，那么这个数就被称为素数。 任意一个整数 (a &gt; 1) 都能分解为 n 个素数之积。 2.合数： 如果一个数大于1，且该数本身不是素数，那么这个数就是一个合数。 3.互质数： 如果两个整数 a，b 的最大公因数 gcd(a, b) &#x3D; 1，那么称 a，b 两数互质。 由于要求最大公因子为正，所以 gcd(a,"><meta name="keywords" content="RSA,CTF"><meta name="author" content="Leonlist"><meta name="copyright" content="Leonlist"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://yoursite.com/2020/09/21/CTF%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="CTF密码学-RSA"><meta property="og:url" content="http://yoursite.com/2020/09/21/CTF%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/"><meta property="og:site_name" content="Leonlist's Blog"><meta property="og:description" content="公钥体制数学基础素数与互素数1.素数： 一个数如果除了1与它本身之外没有其他的因数，那么这个数就被称为素数。 任意一个整数 (a &gt; 1) 都能分解为 n 个素数之积。 2.合数： 如果一个数大于1，且该数本身不是素数，那么这个数就是一个合数。 3.互质数： 如果两个整数 a，b 的最大公因数 gcd(a, b) &#x3D; 1，那么称 a，b 两数互质。 由于要求最大公因子为正，所以 gcd(a,"><meta property="og:image" content="https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png"><meta property="article:published_time" content="2020-09-21T07:21:07.000Z"><meta property="article:modified_time" content="2020-09-21T13:25:05.573Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime: '',
  last_push_date: {"zeroDay":"Today","suffix":"days ago"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-21 21:25:05'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/logo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AC%E9%92%A5%E4%BD%93%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">公钥体制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">数学基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0%E4%B8%8E%E4%BA%92%E7%B4%A0%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">素数与互素数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">欧几里得算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E8%BF%90%E7%AE%97"><span class="toc-number">2.3.</span> <span class="toc-text">模运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">扩展欧几里得算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E5%92%8C%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86"><span class="toc-number">2.5.</span> <span class="toc-text">费马小定理和欧拉定理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">中国剩余定理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RSA%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">RSA算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RSA%E5%B8%B8%E7%94%A8%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">RSA常用攻击方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%95%B0N%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB"><span class="toc-number">4.1.</span> <span class="toc-text">模数N相关攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%86%E8%A7%A3N"><span class="toc-number">4.1.1.</span> <span class="toc-text">直接分解N</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AAN%E4%B8%8D%E4%BA%92%E7%B4%A0"><span class="toc-number">4.1.2.</span> <span class="toc-text">两个N不互素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8CN%EF%BC%8C%E4%B8%8D%E5%90%8Ce%E5%8A%A0%E5%AF%86%E5%90%8C%E6%98%8E%E6%96%87m"><span class="toc-number">4.1.3.</span> <span class="toc-text">同N，不同e加密同明文m</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E9%92%A5%E6%8C%87%E6%95%B0e%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB"><span class="toc-number">4.2.</span> <span class="toc-text">公钥指数e相关攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#e%E5%BE%88%E5%B0%8F%E4%B8%94%E6%98%8E%E6%96%87m%E6%AF%94%E8%BE%83%E5%B0%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">e很小且明文m比较小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e%E4%B8%8E%E6%A8%A1%E6%95%B0N%E7%9A%84%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E7%B4%A0%E6%95%B0%E5%9B%A0%E5%AD%90%E7%9A%84%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E4%B8%8D%E4%BA%92%E7%B4%A0"><span class="toc-number">4.2.2.</span> <span class="toc-text">e与模数N的一个或多个素数因子的欧拉函数不互素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e-3%EF%BC%8C%E6%A8%A1%E6%95%B0N%E7%9B%B8%E5%90%8C%EF%BC%8C%E4%B8%94%E6%98%8E%E6%96%87%E5%AD%98%E5%9C%A8%E7%BA%BF%E6%80%A7%E5%85%B3%E7%B3%BBm1-a-m2-b-mod-N"><span class="toc-number">4.2.3.</span> <span class="toc-text">e&#x3D;3，模数N相同，且明文存在线性关系m1&#x3D;a*m2+b mod N</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wiener-attack"><span class="toc-number">4.2.4.</span> <span class="toc-text">Wiener_attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boneh-and-Durfee-attack"><span class="toc-number">4.2.5.</span> <span class="toc-text">Boneh and Durfee attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E5%8A%A0%E5%AF%86%E6%8C%87%E6%95%B0%E5%B9%BF%E6%92%AD%E6%94%BB%E5%87%BB"><span class="toc-number">4.2.6.</span> <span class="toc-text">低加密指数广播攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Coppersmith%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB"><span class="toc-number">4.3.</span> <span class="toc-text">Coppersmith相关攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Coppersmith%E2%80%99s-short-pad-attack"><span class="toc-number">4.3.1.</span> <span class="toc-text">Coppersmith’s short-pad attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hastad%E2%80%99s-Broadcast-Attack-with-Linear-Padding"><span class="toc-number">4.3.2.</span> <span class="toc-text">Hastad’s Broadcast Attack with Linear Padding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stereotyped-messages%E6%94%BB%E5%87%BB"><span class="toc-number">4.3.3.</span> <span class="toc-text">Stereotyped messages攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial-Key-Exposure-Attack"><span class="toc-number">4.3.4.</span> <span class="toc-text">Partial Key Exposure Attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial-Key-Recovery-Attack"><span class="toc-number">4.3.5.</span> <span class="toc-text">Partial Key Recovery Attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Factoring-with-high-bits-known%E6%94%BB%E5%87%BB"><span class="toc-number">4.3.6.</span> <span class="toc-text">Factoring with high bits known攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%9D%A1%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB"><span class="toc-number">4.4.</span> <span class="toc-text">其他条件相关攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5p%EF%BC%8Cq%E5%85%B6%E4%BB%96%E7%AD%89%E5%BC%8F"><span class="toc-number">4.4.1.</span> <span class="toc-text">已知p，q其他等式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dp-amp-dq%E6%B3%84%E9%9C%B2"><span class="toc-number">4.4.2.</span> <span class="toc-text">dp&amp;dq泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dp%E6%B3%84%E9%9C%B2"><span class="toc-number">4.4.3.</span> <span class="toc-text">dp泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%B4%A0%E6%95%B0%E5%9B%A0%E5%AD%90"><span class="toc-number">4.4.4.</span> <span class="toc-text">多素数因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86"><span class="toc-number">4.4.5.</span> <span class="toc-text">费马小定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next-prime"><span class="toc-number">4.4.6.</span> <span class="toc-text">next_prime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E6%94%BB%E5%87%BB"><span class="toc-number">4.4.7.</span> <span class="toc-text">选择密文攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LSB-Oracle-Attack"><span class="toc-number">4.4.8.</span> <span class="toc-text">LSB Oracle Attack</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leonlist's Blog</a></span><span class="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">CTF密码学-RSA</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-09-21T07:21:07.000Z" title="Created 2020-09-21 15:21:07">2020-09-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-09-21T13:25:05.573Z" title="Updated 2020-09-21 21:25:05">2020-09-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/">CTF</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/Crypto%E5%AD%A6%E4%B9%A0/">Crypto学习</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="公钥体制"><a href="#公钥体制" class="headerlink" title="公钥体制"></a>公钥体制</h1><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="素数与互素数"><a href="#素数与互素数" class="headerlink" title="素数与互素数"></a>素数与互素数</h2><p><strong>1.素数：</strong></p>
<p>一个数如果除了1与它本身之外没有其他的因数，那么这个数就被称为素数。</p>
<p>任意一个整数 (a &gt; 1) 都能分解为 n 个素数之积。</p>
<p><strong>2.合数：</strong></p>
<p>如果一个数大于1，且该数本身不是素数，那么这个数就是一个合数。</p>
<p><strong>3.互质数：</strong></p>
<p>如果两个整数 a，b 的最大公因数 gcd(a, b) = 1，那么称 a，b 两数互质。</p>
<p>由于要求最大公因子为正，所以 gcd(a, b) = gcd(a, -b) = gcd(-a, b) = gcd(-a, -b)。一般gcd(a, b) = gcd(|a|, |b|)。由任一非0整数能整除0，可得 gcd(a, 0) = |a|。如果将a, b都表示为素数的乘积，则 gcd(a, b) 极易确定。</p>
<h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>对于一个大整数而言，我们很难去因式分解，欧几里得算法提供了一个更有效的算法计算gcd，这个算法基于一简单的观察，即：</p>
<p>$gcd(r_0,r_1)=gcd(r_0-r_1,r_1)$</p>
<p>其中，通常假设$r_0 &gt;r_1$，并且两个数均为正整数。此属性的证明非常简单：</p>
<p>假设 $gcd(r_0,r_1)=g$，由于 g 可以同时除 $r_0$ 和 $r_1$，则可以记作 $r_0=g\cdot x$ 和 $r_1 = g\cdot y$，其中 $x&gt;y$，且 x 和 y 为互素的整数，即它们没有公共因子。此外，证明（x - y）与 y互素也非常简单。因此可以得到：</p>
<p>$gcd(r_0-r_1, r_1) = gcd(g\cdot (x-y),g\cdot y)=g$</p>
<p>即使处理非常长的数字（这些数字通常在公钥密码学中使用），欧几里得算法依然高效。迭代次数与输入操作数的位数有紧密的关系。这意味着如果一个 gcd 涉及的数字都是1024位，则此 gcd 的迭代次数就是1024乘以一个常数。几千次迭代的算法在当今 PC 上很容易实现。</p>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>设n是一正整数，a 是整数，如果用 n 除 a，得商为 q，余数为 r，则</p>
<p>$a=qn+r,0\leq r\leq n,q=\lfloor \frac {a}{n}\rfloor$</p>
<p>$\lfloor \frac {a}{n}\rfloor$表示对$\frac {a}{n}$进行下取整</p>
<p>用 $a\space mod\space n$ 表示余数 $r$，则$a=\lfloor \frac {a}{n}\rfloor n+amodn$。</p>
<p>如果$a\space mod\space n=b\space mod\space n$，则称两整数 $a$ 和 $b$ 模 $n$ 同余，记为$a≡b\space mod\space n$。称与 $a$ 模 $n$ 同余的数的全体为 $a$ 的同余类，记为$[a]$，称 $a$ 为这个同余类的表示元素。</p>
<p>注意： 如果$a≡0\space mod\space n$，则 $n$ |$a$</p>
<p>同余有以下性质：</p>
<p>① 若 $n$ | $(a-b)$，则 $a≡b\space mod\space n$</p>
<p>② $a\space mod\space n≡b\space mod\space n$，则$a≡b\space mod\space n$</p>
<p>③ $a≡b\space mod\space n$,则$b≡a\space mod\space n$</p>
<p>④ $a≡b\space mod\space n$，$b≡c\space mod\space n$，则$a≡c\space mod\space n$</p>
<p>从以上性质易知，同余类中的每一元素都可作为这个同余类的表示元素。</p>
<p>求余数运算（简称求余运算）a mod n 将整数 a 映射到集合 {0,1, …,n-1}，称求余运算在这个集合上的算术运算为模运算，模运算有以下性质：</p>
<p>① $[(a\space mod\space n)+(b\space mod\space n)] mod\space n=(a+b) mod\space n$。</p>
<p>② $[(a\space mod\space n)-(b\space mod\space n)] mod\space n=(a-b)\space mod\space n$。</p>
<p>③ $[(a\space mod\space n)×(b\space mod\space n)] mod\space n=(a×b)\space mod\space n$。</p>
<p>性质①的证明： 设 $a\space mod\space n=r_a$，$b\space mod\space n=r_b$，则存在整数$j$、$k$ 使得 $a=j\cdot n+r_a$，$b=k\cdot n+r_b$。</p>
<p>因此</p>
<p>$(a+b)\space mod\space n=[(j+k)n+r_a+r_b]\space mod\space n=(r_a+r_b)\space mod\space n= [(a\space mod\space n)+(b\space mod\space n)]\space mod\space n$</p>
<p>性质②、③的证明类似。</p>
<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>在欧几里得算法的时候我们已经知道两个整数 $r_0$ 和 $r_1$ 的 gcd 的计算可以通过不断进行迭代地减小操作数来实现。然而，事实证明，欧几里得算法的主要应用并不在计算 gcd。扩展的欧几里得算法可以用来计算模逆元，而模逆元在公钥密码学中占有举重若轻的地位。拓展的欧几里得算法除了可以计算 gcd 外，还能计算以下形式的线性组合：</p>
<p>$gcd(r_0,r_1)=s\cdot r_0+t\cdot r_1$</p>
<p>其中s和t均表示整型系数。这个等式通常也称为丢番图方程。</p>
<p>这个算法的思路是：执行标准欧几里得算法，但将每轮迭代中的余数 $r_i$ 表示为以下形式的线性组合：</p>
<p>$r_i=s_ir_0+t_ir_i$</p>
<p>如果这个过程成功了，则最后一轮迭代对应的等式为：</p>
<p>$r_i=gcd(r_0,r_1)=s_ir_0+t_ir_1=sr_0+tr_1$</p>
<p>这也意味着最后一个系数 $s_i$ 也是等式所寻找的系数 s，同时 $t_i=t$。</p>
<h2 id="费马小定理和欧拉定理"><a href="#费马小定理和欧拉定理" class="headerlink" title="费马小定理和欧拉定理"></a>费马小定理和欧拉定理</h2><p><strong>1.费马小定理</strong></p>
<p>定理：若 p 是素数，a 是正整数且 $gcd(a, p)=1$，则 $a^{p-1}≡1\space mod\space p$。</p>
<p>费马小定理也可写成如下形式： 设 p 是素数，a 是任一正整数，则$a^{p}\equiv a\space mod\space p$。</p>
<p><strong>2.欧拉函数</strong></p>
<p>定理: 若 n 是两个素数 p 和 q 的乘积，则$\phi (n)=\phi (p)× \phi (q)=(p-1)×(q-1)$。</p>
<p>设 n 是一正整数，小于n且与n互素的正整数的个数称为n的欧拉函数，记为$\phi (n)$。</p>
<p>例如： $\phi (6)=2$ ，$\phi (7)=6$ ，$\phi (8)=4$。</p>
<p>若n是素数，则显然有 $\phi (n)=n-1$。</p>
<p>定理：若a和n互素，则 $aφ(n) ≡ 1\space mod\space n$。</p>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>中国剩余定理是数论中最有用的一个工具，定理说如果已知某个数关于一些两两互素的数的同余类集，就可重构这个数。</p>
<p>例如：Z_{10} 中每个数都可从这个数关于 2 和 5（10的两个互素的因子）的同余类重构。比如已知 x 关于 2 和 5 的同余类分别是 [0] 和 [3]，即 x mod 2 ≡ 0，x mod 5 ≡ 3。可知是偶数且被 5 除后余数是 3，所以可得8是满足这一关系的惟一的 x。</p>
<p>例如: 求$12\times 13(mod\space 15)$</p>
<p>因为12和13所在的行号分别为 0 和 1，12 和 13 所在的列号分别为 2 和 3，由$0\times 1\equiv 0\space mod\space 3$; $2\times 3\equiv 1\space mod\space 5$得$12\times 13(mod\space 15)$所在的列号和行号分别为 0 和 1，这个位置上的数是6，所以得到$12\times 13(mod\space 15)\equiv 6$。</p>
<p>又因为 $0+1\equiv 1\space mod\space 3$; $2+3\equiv 0\space mod\space 5$第 1 行、第 0 列为 10，所以$12+13\equiv 10\space mod\space 15$。</p>
<p><strong>中国剩余定理：</strong></p>
<p>设$m_1,m_2,…,m_k$是两两互素的正整数，$M=$ 一次同余方程组</p>
<script type="math/tex; mode=display">
\begin{cases}a_1(mod \space m_1) \equiv x \\a_2(mod \space m_2) \equiv x \\ ... \\a_k(mod \space m_k) \equiv x\end{cases}</script><p>对模M有惟一解:</p>
<p>$x\equiv (\frac{M}{m_1}e_1a_1+\frac{M}{m_2}e_2a_2+…+\frac{M}{m_k}e_ka_k)(mod \space M)$</p>
<p>其中 $e_i$ 满足$\frac{M}{m_i}e_i\equiv 1(mod\space m_i)\space(i=1,2,…,k)$</p>
<h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><p><strong>1．密钥生成</strong></p>
<p>① 选取两个保密的大素数p和q。</p>
<p>② 计算$n = p\times q$，$\phi (n)=(p-1)(q-1)$，其中是n的欧拉函数值。</p>
<p>③ 随机选取整数e，满足$1 &lt; e &lt; \phi (n) $ ，且$gcd(e,\phi (n))=1$。</p>
<p>④ 计算d，满足。$de\equiv 1\space mod \space \phi (n)$</p>
<p>⑤ 公钥为$(e,n)$，私钥为$(d, n)$。</p>
<p><strong>2．加密</strong></p>
<p>将明文转换成十进制数，则加密算法为：</p>
<p>$c=m^e\space mod \space n$</p>
<p>c为密文，且 $0 ≤ c &lt; n$。</p>
<p><strong>3．解密</strong></p>
<p>对于密文0≤c＜n，解密算法为：</p>
<p>$m=c^d \space mod \space n$</p>
<p><strong>RSA安全性分析</strong></p>
<p>对于 RSA 加密算法，公钥 (N, e) 为公钥，可以任意公开，破解 RSA 最直接（亦或是暴力）的方法就是分解整数 N，然后计算欧拉函数 φ(n) = (p-1) <em> (q-1)，再通过 d </em> e ≡ 1 mod φ(N)，即可计算出 d，然后就可以使用私钥 (N, d) 通过 m = pow(c,d,N) 解密明文。</p>
<h1 id="RSA常用攻击方法"><a href="#RSA常用攻击方法" class="headerlink" title="RSA常用攻击方法"></a>RSA常用攻击方法</h1><h2 id="模数N相关攻击"><a href="#模数N相关攻击" class="headerlink" title="模数N相关攻击"></a>模数N相关攻击</h2><h3 id="直接分解N"><a href="#直接分解N" class="headerlink" title="直接分解N"></a>直接分解N</h3><ul>
<li><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/yafu/">yafu</a></li>
</ul>
<p>p，q 差值太大或者太小，适用 Fermat 或 Pollard rho 法分解</p>
<p>使用方法：</p>
<p>打开 yafu-x64.exe。</p>
<p>最常用的命令是 factor(n)，将n值分解。</p>
<p>使用yafu的时候遇到mismatched parens：</p>
<p>这是因为在命令行里不支持过长的位数，所以我们只要把n的值从文件中去读取即可。</p>
<p>新建一个文件 pcat.txt，内容里写上 n 的值，如：</p>
<p>注意：<strong>最后面一定要换行</strong>，不然会出现 eof; done processing batchfile</p>
<p>然后运行命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yafu-x64 &quot;factor(@)&quot; -batchfile pcat.txt</span><br></pre></td></tr></table></figure>
<p>输出的结果在 factor.txt 里。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://factordb.com/">factordb网站</a>：N 比特位数 768 或更高，在线网站会存储一些已分解成功的 N。</li>
</ul>
<h3 id="两个N不互素"><a href="#两个N不互素" class="headerlink" title="两个N不互素"></a>两个N不互素</h3><p>通过欧几里德算法求 N1 和 N2 的最大公约数 gmpy2.gcd(n1, n2)，即求得 N 的任意一个因子 p。</p>
<h3 id="同N，不同e加密同明文m"><a href="#同N，不同e加密同明文m" class="headerlink" title="同N，不同e加密同明文m"></a>同N，不同e加密同明文m</h3><p>通过扩展欧几里德算法求出满足 se1 + te2 = 1 mod N 的 s 和 t，再结合对应的密文 c1 和c2 求得明文 m。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcd, s, t = gmpy2.gcdext(e1, e2)</span><br><span class="line">m = gmpy2.powmod(c1, s, N) * gmpy2.powmod(c2, t, N) % N</span><br></pre></td></tr></table></figure>
<h2 id="公钥指数e相关攻击"><a href="#公钥指数e相关攻击" class="headerlink" title="公钥指数e相关攻击"></a>公钥指数e相关攻击</h2><h3 id="e很小且明文m比较小"><a href="#e很小且明文m比较小" class="headerlink" title="e很小且明文m比较小"></a>e很小且明文m比较小</h3><p>以e=3为例</p>
<p>m较小的情况下，从小到大枚举k，依次开e次方根，直到开出整数为止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">  res = gmpy2.iroot(c + i * n, <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">if</span>(res[<span class="number">1</span>] == <span class="literal">True</span>):</span><br><span class="line">     m = res[<span class="number">0</span>]</span><br><span class="line">     print(binascii.unhexlify(hex(m)[<span class="number">2</span>:].strip(<span class="string">&quot;L&quot;</span>)))</span><br><span class="line">     <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">&quot;i=&quot;</span> + str(i)</span><br><span class="line">  i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="e与模数N的一个或多个素数因子的欧拉函数不互素"><a href="#e与模数N的一个或多个素数因子的欧拉函数不互素" class="headerlink" title="e与模数N的一个或多个素数因子的欧拉函数不互素"></a>e与模数N的一个或多个素数因子的欧拉函数不互素</h3><p>N 可以直接分解，但由于e与一个或多个素数因子的欧拉函数不互素，而 e <em> d - k </em> phi(N) = 1 有解的充要条件是 gcd(e, phi(N)) = 1，因此无法直接通过扩展欧几里德算法求模反元素 d。</p>
<p><strong>e=2，Rabin加密解密算法</strong></p>
<p>破解 RSA 的关键即在于大整数的分解，只要 n 被成功分解，就能够破译。而 Rabin 密码体制是对 RSA 的一种修正。</p>
<ol>
<li>Rabin 密码体制对于同一密文，可能有两个以上对应的明文</li>
<li>破译该密码体制同样等价于对大整数的分解，RSA 中选取的公钥 e 满足 $1&lt;e&lt;\varphi(n)$</li>
<li>，而 Rabin 中则选取 e = 2</li>
</ol>
<p>密钥的产生:</p>
<ol>
<li><p>随机选择两个大素数 p，q，通常选取 p，q $\equiv 3(mod \quad4)$</p>
</li>
<li><p>密钥为<code>p</code>，<code>q</code></p>
</li>
<li><p>公钥<code>n=p*q</code></p>
</li>
<li><p>明文：<code>m</code>，密文：<code>c</code></p>
</li>
<li><p>加密：$c \equiv m^2 \quad mod \quad n$</p>
</li>
<li><p>解密过程如下：</p>
<ol>
<li><p>$m_p=c^{\frac{p+1}{4}}mod \quad p$</p>
<p>$m_q=c^{\frac{q+1}{4}}mod \quad q$</p>
</li>
<li><p>使用扩展欧几里得算法得到 $y_p\space和\space y_q$ ，使得 $y_p·p+y_q·q=1$</p>
</li>
<li><p>利用中国剩余定理得到</p>
<p>$x_1=(y_p·p·m_q+y_q·q·m_p) mod \quad n$</p>
<p>$x_2=n-x_1$</p>
<p>$x_3=(y_p·p·m_q-y_q·q·m_p) mod \quad n$</p>
<p>$x_4=n-x_3$</p>
<p>明文为该四个数中的一个。</p>
</li>
</ol>
</li>
</ol>
<p><strong>e=prime * 2^k，</strong><a target="_blank" rel="noopener" href="https://github.com/p4-team/ctf/tree/master/2015-10-18-hitcon/crypto_314_rsabin">Rsabin</a><strong>（hitcon-2015）</strong></p>
<p><strong>素数因子较小，<a target="_blank" rel="noopener" href="https://gist.github.com/elliptic-shiho/98bb452dc14e8c40e403">RSA?</a>（0ctf-2016）</strong></p>
<p>通过以下工具计算：x^e = c mod p 可能的根 x，即为明文 m 对素数因子 p 的余数，依次求出 m 对所有素数因子的余数，再利用中国剩余定理 CRT 即可求得明文 m。</p>
<p><strong>两组e与各自的N的欧拉函数均不互素，</strong><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/3314#toc-6">AzureRSA</a><strong>（高校运维赛eis-2018）</strong></p>
<p>已知：两组N不互素，通过gcd可以求得共同素数因子p，进而求得q1，q2。由于：</p>
<p>$gmpy2.gcd(e1, (p-1))=14$ </p>
<p>$gmpy2.gcd(e1, (q1-1)) = 2 $</p>
<p>$gmpy2.gcd(e2, (p-1)) = 14 $</p>
<p>$gmpy2.gcd(e2, (q2-1)) = 2$</p>
<p>因此，可以利用q1，q2，求得：m^2 对于 q1，q2 的模，进而通过中国剩余定理CRT求得 m^2 对于 q1 * q2 的模，由于所求的值刚好可以开平方，否则需要通过 Rabin 解密法求明文m：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dq1 = gmpy2.invert(e1/<span class="number">2</span>, q1 - <span class="number">1</span>)</span><br><span class="line">dq2 = gmpy2.invert(e2/<span class="number">2</span>, q2 - <span class="number">1</span>)</span><br><span class="line">cq1 = gmpy2.powmod(c1, dq1, q1)</span><br><span class="line">cq2 = gmpy2.powmod(c2, dq2, q2)</span><br><span class="line">m2 = libnum.solve_crt([cq1, cq2], [q1, q2])</span><br><span class="line">m = gmpy2.iroot(m2, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> m[<span class="number">1</span>]: <span class="comment"># if not True, need to use Rabin to cal m</span></span><br><span class="line">  <span class="keyword">print</span> libnum.n2s(m[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="e-3，模数N相同，且明文存在线性关系m1-a-m2-b-mod-N"><a href="#e-3，模数N相同，且明文存在线性关系m1-a-m2-b-mod-N" class="headerlink" title="e=3，模数N相同，且明文存在线性关系m1=a*m2+b mod N"></a>e=3，模数N相同，且明文存在线性关系m1=a*m2+b mod N</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getM2</span>(<span class="params">a, b, c1, c2, n</span>):</span></span><br><span class="line">    a3 = pow(a,<span class="number">3</span>,n)</span><br><span class="line">    b3 = pow(b,<span class="number">3</span>,n)</span><br><span class="line">    first = c1 - a3 * c2 + <span class="number">2</span> * b3</span><br><span class="line">    first = first % n</span><br><span class="line">    second = <span class="number">3</span> * b * (a3 * c2 - b3)</span><br><span class="line">    second = second % n</span><br><span class="line">    third = second * gmpy2.invert(first, n)</span><br><span class="line">    third = third % n</span><br><span class="line">    fourth = (third + b) * gmpy2.invert(a,n)</span><br><span class="line">    <span class="keyword">return</span> fourth % n</span><br><span class="line">m = getM2(a, b, c1, c2, n) - padding2</span><br><span class="line"><span class="keyword">print</span> libnum.n2s(m)</span><br></pre></td></tr></table></figure>
<p>e不为3时，利用Coppersmith’s short-pad attack，即padding过短引起的攻击:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/FranklinReiter.sage">https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/FranklinReiter.sage</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">franklinReiter</span>(<span class="params">n,e,r,c1,c2</span>):</span></span><br><span class="line">    R.&lt;X&gt; = Zmod(n)[]</span><br><span class="line">    f1 = X^e - c1</span><br><span class="line">    f2 = (X + r)^e - c2</span><br><span class="line">    <span class="keyword">return</span> Integer(n-(compositeModulusGCD(f1,f2)).coefficients()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compositeModulusGCD</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> a.monic()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> compositeModulusGCD(b, a % b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CoppersmithShortPadAttack</span>(<span class="params">e,n,C1,C2,eps=<span class="number">1</span>/<span class="number">30</span></span>):</span></span><br><span class="line">    <span class="keyword">import</span> binascii</span><br><span class="line">    P.&lt;x,y&gt; = PolynomialRing(ZZ)</span><br><span class="line">    ZmodN = Zmod(n)</span><br><span class="line">    g1 = x^e - C1</span><br><span class="line">    g2 = (x+y)^e - C2</span><br><span class="line">    res = g1.resultant(g2)</span><br><span class="line">    P.&lt;y&gt; = PolynomialRing(ZmodN)</span><br><span class="line">    rres = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res.coefficients())):</span><br><span class="line">        rres += res.coefficients()[i]*(y^(res.exponents()[i][<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    diff = rres.small_roots(epsilon=eps)</span><br><span class="line">    recoveredM1 = franklinReiter(n,e,diff[<span class="number">0</span>],C1,C2)</span><br><span class="line">    print(recoveredM1)</span><br><span class="line">    print(<span class="string">&quot;Message is the following hex, but potentially missing some zeroes in the binary from the right end&quot;</span>)</span><br><span class="line">    print(hex(recoveredM1))</span><br><span class="line">    print(<span class="string">&quot;Message is one of:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        msg = hex(Integer(recoveredM1*pow(<span class="number">2</span>,i)))</span><br><span class="line">        <span class="keyword">if</span>(len(msg)%<span class="number">2</span> == <span class="number">1</span>):</span><br><span class="line">            msg = <span class="string">&#x27;0&#x27;</span> + msg</span><br><span class="line">        <span class="keyword">if</span>(msg[:<span class="number">2</span>]==<span class="string">&#x27;0x&#x27;</span>):</span><br><span class="line">            msg = msg[:<span class="number">2</span>]</span><br><span class="line">        print(binascii.unhexlify(msg))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testCoppersmithShortPadAttack</span>(<span class="params">eps=<span class="number">1</span>/<span class="number">25</span></span>):</span></span><br><span class="line">    <span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">import</span> binascii</span><br><span class="line">    M = <span class="string">&quot;flag&#123;This_Msg_Is_2_1337&#125;&quot;</span></span><br><span class="line">    M = int(binascii.hexlify(M),<span class="number">16</span>)</span><br><span class="line">    e = <span class="number">3</span></span><br><span class="line">    nBitSize =  <span class="number">8192</span></span><br><span class="line">    key = RSA.generate(nBitSize)</span><br><span class="line">    m = int(math.floor(nBitSize/(e*e))) - <span class="number">400</span></span><br><span class="line">    <span class="keyword">assert</span> (m &lt; nBitSize - len(bin(M)[<span class="number">2</span>:]))</span><br><span class="line">    r1 = random.randint(<span class="number">1</span>,pow(<span class="number">2</span>,m))</span><br><span class="line">    r2 = random.randint(r1,pow(<span class="number">2</span>,m))</span><br><span class="line">    M1 = pow(<span class="number">2</span>,m)*M + r1</span><br><span class="line">    M2 = pow(<span class="number">2</span>,m)*M + r2</span><br><span class="line">    C1 = Integer(pow(M1,e,key.n))</span><br><span class="line">    C2 = Integer(pow(M2,e,key.n))</span><br><span class="line">    CoppersmithShortPadAttack(e,key.n,C1,C2,eps)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFranklinReiter</span>():</span></span><br><span class="line">    p = random_prime(<span class="number">2</span>^<span class="number">512</span>)</span><br><span class="line">    q = random_prime(<span class="number">2</span>^<span class="number">512</span>)</span><br><span class="line">    n = p * q </span><br><span class="line">    e = <span class="number">11</span></span><br><span class="line">    m = randint(<span class="number">0</span>, n) </span><br><span class="line">    r = randint(<span class="number">0</span>, n) </span><br><span class="line">    c1 = pow(m + <span class="number">0</span>, e, n)</span><br><span class="line">    c2 = pow(m + r, e, n)</span><br><span class="line">    print(m)</span><br><span class="line">    recoveredM = franklinReiter(n,e,r,c1,c2)</span><br><span class="line">    print(recoveredM)</span><br><span class="line">    <span class="keyword">assert</span> recoveredM==m</span><br><span class="line">    print(<span class="string">&quot;They are equal!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="Wiener-attack"><a href="#Wiener-attack" class="headerlink" title="Wiener_attack"></a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Wiener&#39;s_attack">Wiener_attack</a></h3><p>假如 p 大于 q 而小于 2q（这是一个很经常的情况）而 $d \lt \frac{1}{3} × N ^{\frac{1}{4}} $，那么从 N 和 e 可以很有效地推算出 d。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">continued_fractions_expansion</span>(<span class="params">numerator,denominator</span>):</span><span class="comment">#(e,N)</span></span><br><span class="line">	result=[] </span><br><span class="line">	divident = numerator % denominator</span><br><span class="line">	quotient = numerator / denominator</span><br><span class="line">	result.append(quotient) </span><br><span class="line">	<span class="keyword">while</span> divident != <span class="number">0</span>:</span><br><span class="line">		numerator = numerator - quotient * denominator </span><br><span class="line">		tmp = denominator</span><br><span class="line">		denominator = numerator</span><br><span class="line">		numerator = tmp</span><br><span class="line">		divident = numerator % denominator</span><br><span class="line">		quotient = numerator / denominator</span><br><span class="line">		result.append(quotient) </span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convergents</span>(<span class="params">expansion</span>):</span></span><br><span class="line">	convergents=[(expansion[<span class="number">0</span>], <span class="number">1</span>)]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(expansion)):</span><br><span class="line">		numerator = <span class="number">1</span></span><br><span class="line">		denominator = expansion[i]</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">			numerator += expansion[j] * denominator</span><br><span class="line">			<span class="keyword">if</span> j==<span class="number">0</span>:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			tmp = denominator</span><br><span class="line">			denominator = numerator</span><br><span class="line">			numerator = tmp</span><br><span class="line">		convergents.append((numerator, denominator)) <span class="comment">#(k,d)</span></span><br><span class="line">	<span class="keyword">return</span> convergents</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newtonSqrt</span>(<span class="params">n</span>):</span></span><br><span class="line">	approx = n / <span class="number">2</span></span><br><span class="line">	better = (approx + n / approx) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">while</span> better != approx:</span><br><span class="line">	    approx = better</span><br><span class="line">	    better = (approx + n / approx) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> approx</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wiener_attack</span>(<span class="params">cons, e, N</span>):</span></span><br><span class="line">	<span class="keyword">for</span> cs <span class="keyword">in</span> cons:</span><br><span class="line">		k,d = cs</span><br><span class="line">		<span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		phi_N = (e * d - <span class="number">1</span>) / k</span><br><span class="line">		a = <span class="number">1</span></span><br><span class="line">		b = -((N - phi_N) + <span class="number">1</span>)</span><br><span class="line">		c = N</span><br><span class="line">		delta = b * b - <span class="number">4</span> * a * c</span><br><span class="line">		<span class="keyword">if</span> delta &lt;= <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		x1 = (newtonSqrt(delta) - b)/(<span class="number">2</span> * a)</span><br><span class="line">		x2 = -(newtonSqrt(delta) + b)/(<span class="number">2</span> * a)</span><br><span class="line">		<span class="keyword">if</span> x1 * x2 == N:</span><br><span class="line">			<span class="keyword">return</span> [x1, x2, k, d]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line">    c = </span><br><span class="line">    expansion = continued_fractions_expansion(e, n)</span><br><span class="line">    cons = convergents(expansion)</span><br><span class="line">    p, q, k, d = wiener_attack(cons, e, n)</span><br><span class="line">    m = pow(c, d, n)</span><br><span class="line">    print(libnum.n2s(m))</span><br></pre></td></tr></table></figure>
<h3 id="Boneh-and-Durfee-attack"><a href="#Boneh-and-Durfee-attack" class="headerlink" title="Boneh and Durfee attack"></a><a target="_blank" rel="noopener" href="https://github.com/mimoo/RSA-and-LLL-attacks">Boneh and Durfee attack</a></h3><p>d 过大，$d \gt \frac{1}{3} × N ^{\frac{1}{4}} $<br>那么可以尝试Boneh and Durfee attack</p>
<h3 id="低加密指数广播攻击"><a href="#低加密指数广播攻击" class="headerlink" title="低加密指数广播攻击"></a>低加密指数广播攻击</h3><p>以e=3为例，3组不同的模数N1，N2，N3互素（如果不互素，可以通过欧几里德算法求最大公约数直接得到p），则有：</p>
<p>C1 = me mod n1</p>
<p>C2 = me mod n2</p>
<p>C3 = me mod n3</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii,gmpy2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CRT</span>(<span class="params">mi, ai</span>):</span></span><br><span class="line">    <span class="keyword">assert</span>(reduce(gmpy2.gcd,mi)==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> (isinstance(mi, list) <span class="keyword">and</span> isinstance(ai, list))</span><br><span class="line">    M = reduce(<span class="keyword">lambda</span> x, y: x * y, mi)</span><br><span class="line">    ai_ti_Mi = [a * (M / m) * gmpy2.invert(M / m, m) <span class="keyword">for</span> (m, a) <span class="keyword">in</span> zip(mi, ai)]</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x + y, ai_ti_Mi) % M</span><br><span class="line">    </span><br><span class="line">e=<span class="number">0x3</span></span><br><span class="line">m=gmpy2.iroot(CRT(n, c), e)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Coppersmith相关攻击"><a href="#Coppersmith相关攻击" class="headerlink" title="Coppersmith相关攻击"></a>Coppersmith相关攻击</h2><p>Coppersmith定理指出在一个e阶的mod n多项式f(x)中，如果有一个根小于n^1/e，就可以运用一个O(log n)的算法求出这些根。</p>
<h3 id="Coppersmith’s-short-pad-attack"><a href="#Coppersmith’s-short-pad-attack" class="headerlink" title="Coppersmith’s short-pad attack"></a><a target="_blank" rel="noopener" href="https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/FranklinReiter.sage">Coppersmith’s short-pad attack</a></h3><p>明文padding长度太短，小于 $floor(nBitSize/(e^2))$</p>
<h3 id="Hastad’s-Broadcast-Attack-with-Linear-Padding"><a href="#Hastad’s-Broadcast-Attack-with-Linear-Padding" class="headerlink" title="Hastad’s Broadcast Attack with Linear Padding"></a><a target="_blank" rel="noopener" href="https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/hastads.sage">Hastad’s Broadcast Attack with Linear Padding</a></h3><p>相同e，e组不同模数N加密明文m的线性关系，</p>
<p>$cArray[i] = pow(aArray[i]*msg + bArray[i],e,nArray[i])$</p>
<p>当aArray[i]=1，bArray[i]=0时，即为低加密指数广播攻击。</p>
<h3 id="Stereotyped-messages攻击"><a href="#Stereotyped-messages攻击" class="headerlink" title="Stereotyped messages攻击"></a>Stereotyped messages攻击</h3><p>至少已知明文m的ceil(nBitSize*(1-1.0/e))位，即知道明文的高位。</p>
<p>如：N.bit_length()=2048，e=3，则至少需要已知：$ceil(2048*(1-1.0/3)) = 1366$位明文</p>
<p>$pol = ((message + ZmodN((pow(2,unknownEndBitIndex)))*x)^e) - c$</p>
<p>当 unknownEndBitIndex = 0 时，即为明文最后字符未知的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">0x3</span></span><br><span class="line">b=<span class="number">0x666c6167206973203a746573743132313131313131313131313133343536000000000000000000</span></span><br><span class="line">n = <span class="number">0xf85539597ee444f3fcad07142ecf6eaae5320301244a7cedc50b2beed7e60ffa11ccf28c1a590fb81346fb16b0cecd046a1f63f0bf93185c109b8c93068ec02f</span></span><br><span class="line">c=<span class="number">0xa75c3c8a19ed9c911d851917e442a8e7b425e4b7f92205ca532a2ab0f5abe6cb86d164cc61374877f9e88e7bca606b43c79f1d59deadfcc68c3db52e5fc42f0</span></span><br><span class="line">kbits=<span class="number">72</span> <span class="comment">#未知低位位数</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = (x + b) ^ e - c</span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;x: %s&quot;</span> %hex(int(x0))</span><br></pre></td></tr></table></figure>
<h3 id="Partial-Key-Exposure-Attack"><a href="#Partial-Key-Exposure-Attack" class="headerlink" title="Partial Key Exposure Attack"></a>Partial Key Exposure Attack</h3><p>已知密钥d的低位d0，d0位数大于 nBitSize / 4。</p>
<p>sage脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_p</span>(<span class="params">p0, kbits, n</span>):</span></span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    nbits = n.nbits()</span><br><span class="line">    f = <span class="number">2</span>^kbits*x + p0</span><br><span class="line">    f = f.monic()</span><br><span class="line">    roots = f.small_roots(X=<span class="number">2</span>^(nbits//<span class="number">2</span>-kbits), beta=<span class="number">0.3</span>)  <span class="comment"># find root &lt; 2^(nbits//2-kbits) with factor &gt;= n^0.3</span></span><br><span class="line">    <span class="keyword">if</span> roots:</span><br><span class="line">        x0 = roots[<span class="number">0</span>]</span><br><span class="line">        p = gcd(<span class="number">2</span>^kbits*x0 + p0, n)</span><br><span class="line">        <span class="keyword">return</span> ZZ(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_p</span>(<span class="params">d0, kbits, e, n</span>):</span></span><br><span class="line">    X = var(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">1</span>, e+<span class="number">1</span>):</span><br><span class="line">        results = solve_mod([e*d0*X - k*X*(n-X+<span class="number">1</span>) + k*n == X], <span class="number">2</span>^kbits)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> results:</span><br><span class="line">            p0 = ZZ(x[<span class="number">0</span>])</span><br><span class="line">            p = partial_p(p0, kbits, n)</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n =<span class="number">0x56a8f8cbc72ff68e67c72718bd16d7e98150aea08780f6c4f532d20ca3c92a0fb07c959e008cbcbeac744854bc4203eb9b2996e9cf630133bc38952a2c17c27d</span> </span><br><span class="line">    e = <span class="number">0x3</span></span><br><span class="line">    d = <span class="number">0x594b6c9631c4987f588399f22466b51fc48ed449b8aae0309b5736ef0b741893</span></span><br><span class="line">    beta = <span class="number">0.5</span></span><br><span class="line">    epsilon = beta^<span class="number">2</span>/<span class="number">7</span></span><br><span class="line"></span><br><span class="line">    nbits = n.nbits()</span><br><span class="line">    kbits = <span class="number">255</span></span><br><span class="line">    d0 = d &amp; (<span class="number">2</span>^kbits<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;lower %d bits (of %d bits) is given&quot;</span> % (kbits, nbits)</span><br><span class="line"></span><br><span class="line">    p = find_p(d0, kbits, e, n)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;found p: %d&quot;</span> % p</span><br><span class="line">    q = n//p</span><br><span class="line">    <span class="keyword">print</span> hex(d)</span><br><span class="line">    <span class="keyword">print</span> hex(inverse_mod(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="Partial-Key-Recovery-Attack"><a href="#Partial-Key-Recovery-Attack" class="headerlink" title="Partial Key Recovery Attack"></a><a target="_blank" rel="noopener" href="https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/RSATool.py">Partial Key Recovery Attack</a></h3><p>已知密钥d的低位d0，d0位数大于 nBitSize / 2</p>
<h3 id="Factoring-with-high-bits-known攻击"><a href="#Factoring-with-high-bits-known攻击" class="headerlink" title="Factoring with high bits known攻击"></a>Factoring with high bits known攻击</h3><p>题目给出p的高位，给出n，e，c</p>
<p>该后门算法依赖于Coppersmith partial information attack算法, sage实现该算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">0xd7e990dec6585656512c841ac932edaf048184bac5ebf9967000000000000000</span></span><br><span class="line">n = <span class="number">0xb50193dc86a450971312d72cc8794a1d3f4977bcd1584a20c31350ac70365644074c0fb50b090f38d39beb366babd784d6555d6de3be54dad3e87a93a703abdd</span></span><br><span class="line"></span><br><span class="line">kbits = <span class="number">60</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x + p</span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;x: %s&quot;</span> %hex(int(x0))</span><br><span class="line">p = p+x0</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;p: &quot;</span>, hex(int(p))</span><br><span class="line"><span class="keyword">assert</span> n % p == <span class="number">0</span></span><br><span class="line">q = n/int(p)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;q: &quot;</span>, hex(int(q))</span><br><span class="line"><span class="comment">#其中kbit是未知的p的低位位数</span></span><br><span class="line"><span class="comment">#x0为求出来的p低位</span></span><br></pre></td></tr></table></figure>
<h2 id="其他条件相关攻击"><a href="#其他条件相关攻击" class="headerlink" title="其他条件相关攻击"></a>其他条件相关攻击</h2><h3 id="已知p，q其他等式"><a href="#已知p，q其他等式" class="headerlink" title="已知p，q其他等式"></a>已知p，q其他等式</h3><p>已知p+q=s，根据一元二次方程：a = 1，b = -s，c = N，可解得：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = long((-b + gmpy2.isqrt(b ** <span class="number">2</span> - <span class="number">4</span>*a*c))/<span class="number">2L</span>) </span><br></pre></td></tr></table></figure>
<h3 id="dp-amp-dq泄露"><a href="#dp-amp-dq泄露" class="headerlink" title="dp&amp;dq泄露"></a>dp&amp;dq泄露</h3><p>dp=d mod (p-1)</p>
<p>dq=d mod (q-1)</p>
<p>这种参数是为了让解密的时候更快速产生的(CRT)。</p>
<p>仅给出p，q，dp，dq，c，不给公钥e；</p>
<p>解密：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inv = gmpy2.invert(q, p)</span><br><span class="line">mp = pow(c,dp,p)</span><br><span class="line">mq = pow(c,dq,q)</span><br><span class="line">m = (((mp - mq) * inv) % p) * q + mq</span><br></pre></td></tr></table></figure>
<h3 id="dp泄露"><a href="#dp泄露" class="headerlink" title="dp泄露"></a>dp泄露</h3><p>给出公钥n,e以及dp</p>
<p>求解私钥d脚本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getd</span>(<span class="params">n,e,dp</span>):</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,e):</span><br><span class="line">     <span class="keyword">if</span> (dp*e<span class="number">-1</span>)%i == <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">if</span> n%(((dp*e<span class="number">-1</span>)/i)+<span class="number">1</span>)==<span class="number">0</span>:</span><br><span class="line">         p=((dp*e<span class="number">-1</span>)/i)+<span class="number">1</span></span><br><span class="line">         phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">         d = gmpy2.invert(e,phi)%phi</span><br><span class="line">         <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>
<h3 id="多素数因子"><a href="#多素数因子" class="headerlink" title="多素数因子"></a>多素数因子</h3><p>公钥 n 由多个素数因子组成。</p>
<p><a target="_blank" rel="noopener" href="https://www.alpertron.com.ar/ECM.HTM">分解整数网站</a></p>
<p>2020国赛初赛的RSA要求分解 n 得到多个素因子，利用 fermat attack。（分解次数10e级别，额……）</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>已知d其他等式，以2为明文，构造p的倍数，使之与N共模</p>
<p>已知：k=(p-r)*d，构造如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp = pow(<span class="number">2</span>, e * k + r - <span class="number">1</span>, n) - <span class="number">1</span></span><br><span class="line">p = libnum.gcd(tmp, n)</span><br></pre></td></tr></table></figure>
<h3 id="next-prime"><a href="#next-prime" class="headerlink" title="next_prime"></a>next_prime</h3><p>原理：根据素数定理，素数的平均间隔为：$x/π(x)≈lnx$，因此常见的下一个素数比当前素数大一点，一般不会超过1500。</p>
<p>可以用 yafu 分解。</p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_theory/#2018-pwnhub-lhy"><strong>LHY</strong></a></p>
<p>已知：p = gmpy.next_prime(x <strong> 3 + y </strong> 3)，q = gmpy.next_prime(x <strong> 2 * y + y </strong> 2 <em> x)，x=2 </em> y</p>
<p>因此：p=next_prime(9 <em> y ** 3) = 9 </em> y <strong> 3 + a，q=next_prime(6  * y </strong> 3) = 6 * y <strong> 3 + b，根据素数定理，a，b很小，因此 n ≈ 54 * y </strong> 6。可以通过以下方法求得p：</p>
<ul>
<li>得知 y 的上界，而y的下界也不会离上界太远，可以利用二分查找法来寻找满足条件的y，p 和 q</li>
<li>由于a，b很小，y如果改变，y <strong> 3改变的值将远大于 a，b 的影响，因此可以认为y = iroot(y / 54,  6)，进而爆破a（从1到1500）求得：p = next_prime(9 * y </strong> 3) = (9 <em> y *</em>3 + a) % n = 0，比直接求 next_prime 速度快些</li>
<li>p = 9 <em> y *</em>3 + a，由于a，b 很小，可以认为 p 高位大部分 bit 已知，通过 Coppersmith 攻击可恢复不确定的低位。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">tmp = </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> gmpy2.iroot(tmp, <span class="number">2018</span>)</span><br><span class="line"><span class="keyword">print</span> gmpy2.iroot(tmp - <span class="number">1</span>, <span class="number">2018</span>)</span><br><span class="line"><span class="keyword">print</span> gmpy2.iroot(tmp - <span class="number">2</span>, <span class="number">2018</span>)</span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">y = </span><br><span class="line">y = gmpy2.next_prime(y)</span><br><span class="line"></span><br><span class="line">enc = </span><br><span class="line"></span><br><span class="line">end = gmpy2.iroot(n / <span class="number">54</span>, <span class="number">6</span>)[<span class="number">0</span>]</span><br><span class="line">beg = end - <span class="number">2000000</span></span><br><span class="line"></span><br><span class="line">mid = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> beg &lt; end:</span><br><span class="line">    mid = (beg + end) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> gmpy2.is_prime(mid) != <span class="number">1</span>:</span><br><span class="line">        mid = gmpy2.next_prime(mid)</span><br><span class="line">    p = gmpy2.next_prime(<span class="number">9</span> * mid**<span class="number">3</span>)</span><br><span class="line">    q = gmpy2.next_prime(<span class="number">6</span> * mid**<span class="number">3</span>)</span><br><span class="line">    n1 = p * q</span><br><span class="line">    <span class="keyword">if</span> n1 == n:</span><br><span class="line">        <span class="keyword">print</span> p, q</span><br><span class="line">        phin = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">        d = gmpy2.invert(<span class="number">0x10001</span>, phin)</span><br><span class="line">        m = gmpy2.powmod(enc, d, n)</span><br><span class="line">        <span class="keyword">print</span> hex(m)[<span class="number">2</span>:].strip(<span class="string">&#x27;L&#x27;</span>).decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> n1 &lt; n:</span><br><span class="line">        beg = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        end = mid</span><br><span class="line">    <span class="keyword">print</span> beg, end</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://bbs.ichunqiu.com/thread-36705-1-1.html">已知nextprime(p)*nexprime(q)的值</a></p>
<p>$npnq = nextprime(p) <em> nextprime(q) = (p + x) </em> (q + y)$</p>
<p>联立 $p * q = N$，得：</p>
<p>$y <em> p ** 2 + (n + x </em> y - npnq) <em> p + x </em> n = 0$</p>
<p>爆破 x 和 y（从1到1500）解一元二次方程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n = </span><br><span class="line">m = </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadratic</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    ga=gmpy2.mpz(a)</span><br><span class="line">    gb=gmpy2.mpz(b)</span><br><span class="line">    gc=gmpy2.mpz(c)</span><br><span class="line">    delta=gb**<span class="number">2</span><span class="number">-4</span>*ga*gc</span><br><span class="line">    <span class="keyword">if</span> delta&lt;=<span class="number">0</span> <span class="keyword">or</span> a==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    tmp=gmpy2.iroot(delta,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> tmp[<span class="number">1</span>]==<span class="literal">True</span>:</span><br><span class="line">        x1 = (-gb + tmp[<span class="number">0</span>]) / (<span class="number">2</span>*ga)</span><br><span class="line">        x2 = (-gb - tmp[<span class="number">0</span>]) / (<span class="number">2</span> * ga)</span><br><span class="line">        <span class="keyword">if</span> x1&gt;<span class="number">0</span> <span class="keyword">and</span> n%x1==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> x1</span><br><span class="line">            <span class="keyword">return</span> x1</span><br><span class="line">        <span class="keyword">if</span> x2&gt;<span class="number">0</span> <span class="keyword">and</span> n%x2==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> x2</span><br><span class="line">            <span class="keyword">return</span> x2</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1500</span>):</span><br><span class="line">        <span class="keyword">print</span> x</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1500</span>):</span><br><span class="line">            a=y</span><br><span class="line">            b=x * y - m + n</span><br><span class="line">            c=x * n</span><br><span class="line">            <span class="keyword">if</span> quadratic(a,b,c)!=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="选择密文攻击"><a href="#选择密文攻击" class="headerlink" title="选择密文攻击"></a>选择密文攻击</h3><p>任意给定密文，系统返回明文，选择密文攻击。</p>
<p><a target="_blank" rel="noopener" href="http://skysec.top/2018/09/17/2018-noxCTF-Crypto-RSA/#Decryptor">Decryptor</a><strong>（noxCTF-2018）</strong></p>
<p>已知n，c，e，向服务器发送密文得到明文。</p>
<p>构造一个 x，使得：</p>
<p>$k \equiv x^ec \text{ } mod \text{ } n$</p>
<p>然后我们把 k 发送过去，得到：</p>
<p>$k^d \equiv (x^ec)^d \text{ } mod \text{ } n$</p>
<p>$ k^d \equiv xc^d \text{ } mod \text{ } n $</p>
<p>$ k^dx^-1 \equiv m \text{ } mod \text{ } n $</p>
<p>我们构造 x=2 即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = hex((pow(<span class="number">2</span>,e,N)*c)%N)[<span class="number">2</span>:<span class="number">-1</span>]</span><br><span class="line"><span class="comment">#put x</span></span><br><span class="line"><span class="comment">#get tmp</span></span><br><span class="line">libnum.n2s((tmp*gmpy2.invert(<span class="number">2</span>,N))%N)</span><br></pre></td></tr></table></figure>
<h3 id="LSB-Oracle-Attack"><a href="#LSB-Oracle-Attack" class="headerlink" title="LSB Oracle Attack"></a>LSB Oracle Attack</h3><p>适用情况：可以选择密文并泄露最低位。</p>
<p>在一次RSA加密中，明文为m，模数为n，加密指数为e，密文为c。</p>
<p>我们可以构造出 $c’=((2^e)<em>c)%n=((2^e)</em>(m^e))%n=((2*m)^e)%n$ </p>
<p>因为 m 的两倍可能大于 n，所以经过解密得到的明文是  $m’=(2*m)%n $。</p>
<p>我们还能够知道 $m’ $的最低位lsb 是1还是0。<br>因为n是奇数，而 2 <em> m 是偶数，所以如果 lsb 是0，说明 (2 </em> m)%n ​是偶数，没有超过 n，即 m &lt; n / 2.0，反之则 m &gt; n / 2.0 。<br>举个例子就能明白 2 % 3 = 2 是偶数，而 4 % 3 = 1 是奇数。<br>以此类推，构造密文$c” = ((4^e)<em>c) \space mod \space n $使其解密后为$m” = (4 </em> m)%n$ ，判断 m” 的奇偶性可以知道 m 和 n/4 的大小关系。<br>所以我们就有了一个二分算法，可以在对数时间内将m的范围逼近到一个足够狭窄的空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brute_flag</span>(<span class="params">encrypted_flag, n, e</span>):</span></span><br><span class="line"></span><br><span class="line">    flag_count = n_count = <span class="number">1</span></span><br><span class="line">    flag_lower_bound = <span class="number">0</span></span><br><span class="line">    flag_upper_bound = n</span><br><span class="line">    ciphertext = encrypted_flag</span><br><span class="line">    mult = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> flag_upper_bound &gt; flag_lower_bound + <span class="number">1</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;input your option:&quot;</span>)</span><br><span class="line">        sh.sendline(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">        ciphertext = (ciphertext * pow(<span class="number">2</span>, e, n)) % n</span><br><span class="line">        flag_count *= <span class="number">2</span></span><br><span class="line">        n_count = n_count * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">        print(<span class="string">&quot;bit = %d&quot;</span> % mult)</span><br><span class="line">        mult += <span class="number">1</span></span><br><span class="line">        sh.recvuntil(<span class="string">&quot;Your encrypted message:&quot;</span>)</span><br><span class="line">        sh.sendline(str(ciphertext))</span><br><span class="line">        data=sh.recvline()[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span>(data==<span class="string">&#x27;The plain of your decrypted message is even!&#x27;</span>):</span><br><span class="line">            flag_upper_bound = n * n_count / flag_count</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag_lower_bound = n * n_count / flag_count</span><br><span class="line">            n_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> flag_upper_bound</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Leonlist</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/09/21/CTF%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/">http://yoursite.com/2020/09/21/CTF%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RSA/">RSA</a><a class="post-meta__tags" href="/tags/CTF/">CTF</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/22/BUUCTF%E5%88%B7%E9%A2%98-RSA/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2019/11/10/gcnavZbmepS8d4u.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">BUUCTF刷题-RSA</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/11/pwn%E5%85%A5%E9%97%A8-%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA/"><img class="next-cover" data-lazy-src="https://i.loli.net/2019/11/10/egVhFWopA5mP2Hk.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">pwn入门-花式栈溢出</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/09/22/BUUCTF刷题-RSA/" title="BUUCTF刷题-RSA"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2019/11/10/gcnavZbmepS8d4u.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-22</div><div class="relatedPosts_title">BUUCTF刷题-RSA</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Leonlist</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>