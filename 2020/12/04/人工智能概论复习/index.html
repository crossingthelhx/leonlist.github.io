<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>人工智能概论复习 | Leonlist's Blog</title><meta name="description" content="人工智能概论学习，复习笔记"><meta name="keywords" content="人工智能"><meta name="author" content="Leonlist"><meta name="copyright" content="Leonlist"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://yoursite.com/2020/12/04/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="人工智能概论复习"><meta property="og:url" content="http://yoursite.com/2020/12/04/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/"><meta property="og:site_name" content="Leonlist's Blog"><meta property="og:description" content="人工智能概论学习，复习笔记"><meta property="og:image" content="https://i.loli.net/2019/11/10/lP3rLNUBaGtSVzc.png"><meta property="article:published_time" content="2020-12-04T14:49:37.000Z"><meta property="article:modified_time" content="2021-01-12T13:57:32.035Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime: '',
  last_push_date: {"zeroDay":"Today","suffix":"days ago"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-01-12 21:57:32'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/logo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">导论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0"><span class="toc-number">2.</span> <span class="toc-text">统计学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%9F%E5%90%88%E6%95%88%E6%9E%9C%E6%A3%80%E9%AA%8C"><span class="toc-number">2.1.</span> <span class="toc-text">拟合效果检验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%8B%9F%E5%90%88"><span class="toc-number">2.2.</span> <span class="toc-text">过拟合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%B7%AE-%E6%96%B9%E5%B7%AE%E5%9D%87%E8%A1%A1"><span class="toc-number">2.3.</span> <span class="toc-text">偏差-方差均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">分类模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">贝叶斯分类器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K%E6%9C%80%E8%BF%91%E9%82%BB%EF%BC%88KNN%EF%BC%89%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">K最近邻（KNN）分类器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-number">3.</span> <span class="toc-text">线性回归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-number">3.1.</span> <span class="toc-text">简单线性回归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B0%E8%AE%A1%E7%B3%BB%E6%95%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">估计系数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0%E7%B3%BB%E6%95%B0%E4%BC%B0%E8%AE%A1%E5%80%BC%E7%9A%84%E5%87%86%E7%A1%AE%E6%80%A7"><span class="toc-number">3.1.2.</span> <span class="toc-text">评估系数估计值的准确性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%87%86%E7%A1%AE%E6%80%A7"><span class="toc-number">3.1.3.</span> <span class="toc-text">评价模型的准确性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B0%E8%AE%A1%E5%9B%9E%E5%BD%92%E7%B3%BB%E6%95%B0"><span class="toc-number">3.1.4.</span> <span class="toc-text">估计回归系数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.5.</span> <span class="toc-text">一些重要问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%8F%98%E9%87%8F%E5%92%8C%E9%A2%84%E6%B5%8B%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E6%98%AF%E5%90%A6%E6%9C%89%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">响应变量和预测变量之间是否有关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%93%8D%E5%BA%94%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">预测变量与响应变量的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8B%9F%E5%90%88%E7%A8%8B%E5%BA%A6"><span class="toc-number">3.1.5.3.</span> <span class="toc-text">模型的拟合程度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%A2%84%E6%B5%8B%E5%80%BC%EF%BC%8C%E9%A2%84%E6%B5%8B%E7%9A%84%E5%87%86%E7%A1%AE%E7%A8%8B%E5%BA%A6%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">3.1.5.4.</span> <span class="toc-text">如何预测值，预测的准确程度如何？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92"><span class="toc-number">4.1.</span> <span class="toc-text">逻辑斯谛回归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">逻辑斯谛回归模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B0%E8%AE%A1%E5%9B%9E%E5%BD%92%E7%B3%BB%E6%95%B0-1"><span class="toc-number">4.1.2.</span> <span class="toc-text">估计回归系数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92"><span class="toc-number">4.1.3.</span> <span class="toc-text">多元逻辑斯谛回归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">线性判别分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86"><span class="toc-number">4.2.1.</span> <span class="toc-text">贝叶斯定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p-1%E7%9A%84%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90"><span class="toc-number">4.2.2.</span> <span class="toc-text">p&#x3D;1的线性判别分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p-gt-1%E7%9A%84%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90"><span class="toc-number">4.2.3.</span> <span class="toc-text">p&gt;1的线性判别分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90"><span class="toc-number">4.2.4.</span> <span class="toc-text">二次判别分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.3.</span> <span class="toc-text">分类方法的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E6%8A%BD%E6%A0%B7%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">重抽样方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">交叉验证法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E9%9B%86%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">验证集方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%95%99%E4%B8%80%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">留一交叉验证法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k%E6%8A%98%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95"><span class="toc-number">5.1.3.</span> <span class="toc-text">k折交叉验证法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">自助法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E4%BC%B0%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">压缩估计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%AD%E5%9B%9E%E5%BD%92-ridge-regression"><span class="toc-number">6.1.</span> <span class="toc-text">岭回归(ridge regression)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lasso"><span class="toc-number">6.2.</span> <span class="toc-text">lasso</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92"><span class="toc-number">7.</span> <span class="toc-text">多项式回归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%A0%91%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">基于树的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E6%A0%91%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">决策树基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E6%A0%91"><span class="toc-number">8.1.1.</span> <span class="toc-text">回归树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E6%A0%91"><span class="toc-number">8.1.2.</span> <span class="toc-text">分类树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">8.1.3.</span> <span class="toc-text">树与线性模型的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.1.4.</span> <span class="toc-text">树的优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19%E5%B9%B4%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95"><span class="toc-number">9.</span> <span class="toc-text">19年期末考试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92"><span class="toc-number">9.1.</span> <span class="toc-text">回归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-1"><span class="toc-number">9.2.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18%E5%B9%B4%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95"><span class="toc-number">10.</span> <span class="toc-text">18年期末考试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%A2%98"><span class="toc-number">10.1.</span> <span class="toc-text">判断题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92-1"><span class="toc-number">10.2.</span> <span class="toc-text">多项式回归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-2"><span class="toc-number">10.3.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81"><span class="toc-number">10.4.</span> <span class="toc-text">交叉验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E4%B8%BE%E6%B3%95"><span class="toc-number">10.5.</span> <span class="toc-text">自举法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18%E5%B9%B4%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95"><span class="toc-number">11.</span> <span class="toc-text">18年期中考试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%A2%98-1"><span class="toc-number">11.1.</span> <span class="toc-text">判断题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E9%A2%98"><span class="toc-number">11.2.</span> <span class="toc-text">计算题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E9%A2%98"><span class="toc-number">11.3.</span> <span class="toc-text">推导题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E9%A2%98"><span class="toc-number">11.4.</span> <span class="toc-text">附加题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">12.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2019/11/10/lP3rLNUBaGtSVzc.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leonlist's Blog</a></span><span class="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">人工智能概论复习</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-12-04T14:49:37.000Z" title="Created 2020-12-04 22:49:37">2020-12-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-01-12T13:57:32.035Z" title="Updated 2021-01-12 21:57:32">2021-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Study/">Study</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><p>统计学习是一套以<strong>理解数据</strong>为目的的庞大工具集。一般有两个用途：一是面向预测的统计模型的建立，二是对一个或多个给定的<strong>输入</strong>估计某个<strong>输出</strong>。</p>
<p><strong>预测</strong>：运用线性回归模型来预测数据</p>
<p><strong>分类</strong>：预测一个非数据变量，即分类或定性的输出</p>
<p><strong>聚类</strong>：不打算预测变量，而是对输入变量的属性进行分类聚合，形成一个个族群</p>
<h1 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h1><h2 id="拟合效果检验"><a href="#拟合效果检验" class="headerlink" title="拟合效果检验"></a>拟合效果检验</h2><p>在回归中，最常用的评价准则是均方误差（MSE）:</p>
<script type="math/tex; mode=display">MSE=\frac{1}{n} \sum_{i=1}^{n}(y_i-\hat{f}(x_i))^2</script><p>$\hat{f}(x_i) $为预测值</p>
<p>如果预测的响应值与真实的响应值存在实质上的差别，则均方误差会非常大</p>
<p>用训练数据计算的均方误差称为训练均方误差</p>
<p>但我们更在意测试点的测试均方误差，可计算如下函数：</p>
<script type="math/tex; mode=display">Ave(\hat{f}(x_0)-y_0)^2</script><p>这是测试观测点$(x_0,y_0)$的均方测试误差。</p>
<h2 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h2><p>过拟合：当模型的光滑度增加时，训练均方误差将降低，但测试均方误差不一定会降低。当所建的模型产生一个较小的训练均方误差，但却有一个较大的测试均方误差，就称该数据过拟合。</p>
<p>出现过拟合的原因：</p>
<ol>
<li>训练集的数据太少</li>
<li>训练集和新数据的特征分布不一致</li>
<li>训练集中存在噪音。噪音大到模型过分记住了噪音的特征，反而忽略了真实的输入输出间的关系。</li>
</ol>
<h2 id="偏差-方差均衡"><a href="#偏差-方差均衡" class="headerlink" title="偏差-方差均衡"></a>偏差-方差均衡</h2><p>期望测试方差能分解成三个基本量的和，分别为：预测值的方差、预测值偏差的方差和误差项<script type="math/tex">\varepsilon</script>的方差，即：</p>
<script type="math/tex; mode=display">E(y_0-\hat{f}(x_0))^2=Var(\hat{f}(x_0))+[Bias(\hat{f}(x_0))]^2+Var(\epsilon)</script><p><strong>证明过程：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20210110211318135.png" alt="image-20210110211318135" style="zoom:80%;" /></p>
<p>学习算法的期望预测（（数据分布Ɗ）训练出的【所有模型预测输出】的期望值，就是平均值）：</p>
<p>（下面的x等同于上式的$\hat{f}(x_0)$，即预测值）</p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20210109171748392.png" alt="image-20210109171748392" style="zoom:80%;" /></p>
<p><strong>方差（variance）</strong>代表的是用一个不同的训练数据集估计$f$时，估计函数的改变量。因为训练数据是用来拟合统计学习方法的，因此不同的数据集会得到不同的$f$。一般来说，光滑度越高的统计模型会有更大的方差。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/v2-2a7a3d2a6ec09d77b1171eeee65c8ad5_r.jpg" alt="img" style="zoom:67%;" /></p>
<p><strong>偏差（bias）</strong>指为了选择一个简单的模型逼近真实函数而被带入的误差，其构成可能非常复杂。因为真实的$f$实际上是非线性的，所以使用线性回归不会有太多的精准估计。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/v2-295fb8547dbfcf04cc6127ffb51b9e57_720w.jpg" alt="img" style="zoom:67%;" /></p>
<p>Bias是用所有可能的训练数据集训练出的所有模型的输出的平均值与真实模型的输出值之间的差异。</p>
<p>Variance是不同的训练数据集训练出的模型输出值之间的差异。</p>
<p>下图，蓝色实曲线表示在不同光滑度下偏差的平方，而橙色曲线表示方差，水平曲线表示不可约误差，即$Var(\varepsilon)$。表达测试均方误差的红色曲线是三个量的和。</p>
<p>中图，真实的f接近线性，因此当模型光滑度增加时，偏差只发生了微小的变化，测试均方误差由于方差的迅速增大导致迅速增长</p>
<p>右图，真实的f是非线性的，随着所选模型光滑度的增加，偏差会急剧减小。随着光滑度的增长，方差也有很小的增加。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20210110104159138.png" alt="image-20210110104159138" style="zoom: 80%;" /></p>
<p>一般而言，使用<strong>光滑度（flexible）</strong>越高的方法，所得的模型方差会增加，偏差会减少。这两个量比值的相对变化率会导致测试均方误差整体的增加或变小，所以偏差-方差的权衡是一个重要探讨主题。</p>
<h2 id="分类模型"><a href="#分类模型" class="headerlink" title="分类模型"></a>分类模型</h2><h3 id="贝叶斯分类器"><a href="#贝叶斯分类器" class="headerlink" title="贝叶斯分类器"></a>贝叶斯分类器</h3><p>可以设计一个非常简单的分类器将每个观测值分配到它最大可能所在类别中，将这个类作为它的预测值即可。将一个待判 $x_0$分配到下面这个式子最大的那个 j 类上是合理的：</p>
<script type="math/tex; mode=display">Pr(Y=j|X=x_0)</script><p> 上式是一个条件概率，给定了观测向量$x_0$条件下$Y=j$的概率。这类方法称为贝叶斯分类器。</p>
<p><strong>贝叶斯决策边界</strong>由那些概率等于50%的点组成</p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20210108133847652.png" alt="image-20210108133847652" style="zoom:67%;" /></p>
<p>（上图从二分类数据中的每一类中抽取100个观测值组成应该模拟数据集。观测点由蓝色和橙色表示。紫色的虚线表示贝叶斯决策边界。橙色的背景方格表示其中的测试观测值将会归到橙色类中，蓝色背景的方格表示其中的测试观测值将会归到蓝色类中）</p>
<h3 id="K最近邻（KNN）分类器"><a href="#K最近邻（KNN）分类器" class="headerlink" title="K最近邻（KNN）分类器"></a>K最近邻（KNN）分类器</h3><p>给定一个正整数$k$和一个测试观测值$x_0$，KNN分类从识别训练集中$k$个最靠近$x_0$的点集开始，从点集中的点估计一个分值作为条件概率的估计，这个值等于$j$：</p>
<script type="math/tex; mode=display">Pr(Y=j|X=x_0)=\frac{1}{K}\sum\limits_{i\epsilon N}I(y_i=j)</script><p>最后，对KNN方法运用贝叶斯规则将测试观测值$x_0$分到概率最大的类中。</p>
<p>简单讲，比如对一个点进行黑白色分类，选靠近它的K个点，算出黑色和白色的估计概率，判断它是黑色点还是白色点。依此类推，可以绘制出相应的KNN决策边界。</p>
<p>K增加时，会导致方差降低，但偏差增加。</p>
<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><h2 id="简单线性回归"><a href="#简单线性回归" class="headerlink" title="简单线性回归"></a>简单线性回归</h2><p>非常简单的根据单一预测变量X预测定量响应变量Y的方法，其线性关系为：</p>
<script type="math/tex; mode=display">Y \approx \beta_0+\beta_1X</script><h3 id="估计系数"><a href="#估计系数" class="headerlink" title="估计系数"></a>估计系数</h3><p>我们需要获得系数估计<script type="math/tex">\hat{\beta}_0,\hat{\beta}_1</script>,以使线性模型较好的拟合现有数据。</p>
<p>$e_i=y_i-\hat{y_i}$代表第 i 个残差——第 i 个观测到的响应值和第 i 个用线性模型预测出的响应值之间的差距。</p>
<p>定义残差平方和（RSS）为：</p>
<script type="math/tex; mode=display">RSS=e_1^2+e_2^2+e_3^2+...e_n^2</script><p>或等价定义为：</p>
<script type="math/tex; mode=display">RSS=（y_1-\hat{\beta}_0-\hat{\beta}_1x_1）^2+（y_2-\hat{\beta}_0-\hat{\beta}_1x_2）^2+...+（y_n-\hat{\beta}_0-\hat{\beta}_1x_n）^2</script><p>通过最小二乘法选择系数使RSS最小，系数即：</p>
<script type="math/tex; mode=display">\hat{\beta_1}=\frac{\sum^{n}\limits_{i=1}{(x_i-\overline{x})(y_i-\overline{y})}}{\sum^{n}\limits_{i=1}{(x_i-\overline{x})^2}}</script><script type="math/tex; mode=display">\hat{\beta_0}=\overline{y}-\hat{\beta_1}\overline{x}</script><p>上式定义了简单线性回归系数的最小二乘估计</p>
<h3 id="评估系数估计值的准确性"><a href="#评估系数估计值的准确性" class="headerlink" title="评估系数估计值的准确性"></a>评估系数估计值的准确性</h3><p>线性回归和随机变量的均值估计之间的类比是一个恰当的基于<strong>偏差</strong>（bias）概念的类比。如果用样本均值$\hat\mu$来估计总体均值$\mu$，这个估计是无偏的（无偏是指我们期望样本均值等于总体均值）。但往往在不同观测值上，会有偏大偏小的情况出现。所以我们尽量对从大量数据集上得到的估计值求平均，使得接近于真实总体回归直线。</p>
<p>我们通常通过计算$\hat{\mu}$的标准误差（standard error，写作$SE(\hat\mu)^2$，来评价样本均值$\hat\mu$作为总体均值$\mu$的估计有多准确：</p>
<script type="math/tex; mode=display">Var(\hat{u})=SE(\hat{u})^2=\frac{\sigma^2}{n}</script><p>其中，$\sigma$是变量$Y$的实现每个实现值$y_i$的标准差。粗略的说，标准误差告诉我们估计$\hat{\mu}$偏离$\mu$的实际值的平均量。</p>
<p>对$\sigma^2$的估计被称为<strong>残差标准误（residual standard error）</strong>，由公式$RSE=\sqrt{RSS/(n-2)}$所定义</p>
<h3 id="评价模型的准确性"><a href="#评价模型的准确性" class="headerlink" title="评价模型的准确性"></a>评价模型的准确性</h3><p>量化模型拟合数据的程度</p>
<p>判断线性回归的拟合质量通常使用<strong>残差标准误(RSE)</strong>和<strong><script type="math/tex">R^2</script>统计量</strong></p>
<p><strong>残差标准误</strong></p>
<p>每个观测都有误差项<script type="math/tex">\epsilon</script>，因为误差存在，所以不能用X对Y作出完美预测。</p>
<p>RSE是对<script type="math/tex">\epsilon</script>的标准偏差的估计。</p>
<script type="math/tex; mode=display">RSE=\sqrt{\frac{1}{n-2}RSS}=\sqrt{\frac{1}{n-2}\sum^{n}\limits_{i=1}(y_i-\hat{y_i})^2}</script><p>如果RSE值相当小，那么可以认为该模型很好的拟合了数据，如果在多个观测中，<script type="math/tex">y_i、\hat{y_i}</script>相差很大，那么RSE可能是相当大的，表明该模型未能很好的拟合数据</p>
<p><strong><script type="math/tex">R^2</script>统计量</strong></p>
<p>RSE是以Y为标准衡量的，所以并不清楚构成良好的RSE的要素有哪些。<script type="math/tex">R^2</script>统计量采用比例（proportion）（被解释方差的比例）的形式，值在0到1之间，与Y的量级无关</p>
<script type="math/tex; mode=display">R^2=\frac{TSS-RSS}{TSS}=1-\frac{RSS}{TSS}</script><script type="math/tex; mode=display">TSS=\sum(y_i-\overline{y})^2$$是总平方和

$$R^2$$测量的是Y的变异中能被X解释的部分所占比例，$$R^2$$统计量接近1说明回归可以解释响应变量的大部分变异。$$R^2$$统计量接近0说明回归没有太多响应变量的变异，这可能因为线性模型是错误的，也可能因为固有误差项$$\sigma^2$$较大，抑或两者皆有。

同时相关性也衡量了X和Y之间的线性关系，这意味着 $$r=Cor(X,Y)$$可以代替$$R^2$$评估线性模型的拟合度。事实上，在简单的线性回归模型中，$$R^2=r^2$$，也就是相关系数的平方与$$R^2$$统计量相等。

## 多元线性回归

多元线性回归模型的形式为：

$$Y \approx \beta_0+\beta_1X_1+\beta_2X_2+...+\beta_pX_p+\epsilon</script><h3 id="估计回归系数"><a href="#估计回归系数" class="headerlink" title="估计回归系数"></a>估计回归系数</h3><p>类似的如下：</p>
<script type="math/tex; mode=display">RSS=\sum^{n}\limits_{i=1}（y_i-\hat{y}_i)^2=\sum^{n}\limits_{i=1}（y_1-\hat{\beta}_0-\hat{\beta}_1x_{i1}-\hat{\beta}_2x_{i2}-...-\hat{\beta}_px_{xp}）^2</script><h3 id="一些重要问题"><a href="#一些重要问题" class="headerlink" title="一些重要问题"></a>一些重要问题</h3><h4 id="响应变量和预测变量之间是否有关系？"><a href="#响应变量和预测变量之间是否有关系？" class="headerlink" title="响应变量和预测变量之间是否有关系？"></a>响应变量和预测变量之间是否有关系？</h4><p>计算<strong>F统计量</strong>：</p>
<script type="math/tex; mode=display">F=\frac{(TSS-RSS)/p}{RSS/(n-p-1)}</script><p>（p为预测变量的个数）</p>
<p>当响应变量与预测变量无关，F统计量应该接近1。</p>
<p>如果F统计量远大于1，那么我们可以认为响应变量与预测变量有关。</p>
<p>那F统计量需要多大才行呢？这取决于样本量n和p的值。如果n很大，即使F统计量略大于1，可能认为有关；如果n较小，需要较大的F统计量证明有关。</p>
<p>似乎，如果任一变量的p值很小，那么至少有一个预测变量与响应变量有关，但当预测变量的数目很大的时候该结论会有缺陷。所以当变量数特别多时，我们甚至不能用最小二乘法拟合多元线性模型，F统计量也无法使用。</p>
<h4 id="预测变量与响应变量的关系"><a href="#预测变量与响应变量的关系" class="headerlink" title="预测变量与响应变量的关系"></a>预测变量与响应变量的关系</h4><p>多元回归分析的第一步是计算F统计量并检查相应的p值。</p>
<p>我们确定哪些变量是和响应变量有关，以建立只包含相关预测变量的模型的任务被称为变量选择。（关于变量选择，蓝珲可能讲不到：）</p>
<h4 id="模型的拟合程度"><a href="#模型的拟合程度" class="headerlink" title="模型的拟合程度"></a>模型的拟合程度</h4><ul>
<li><p>两个常见的衡量模型拟合优劣的指标的RSE和<script type="math/tex">R^2</script>.</p>
</li>
<li><p>若<script type="math/tex">R^2</script>值接近1，则表明该模型能解释响应变量的大部分方差。</p>
</li>
<li>当更多的变量进入模型时，即时新加入的变量与响应变量的关联很弱，$R^2$也一定会增加</li>
<li>变量增加，模型越复杂，拟合的准确性越高，残差平方和减小</li>
<li><p>当RSE值越高，拟合程度越高。</p>
</li>
<li><p>但注意，预测变量增加，RSS在必然减少（拟合程度降低）的情况下，RSE反而会增加。也就是说，变量较多的模型可能有更高的RSE。</p>
</li>
</ul>
<h4 id="如何预测值，预测的准确程度如何？"><a href="#如何预测值，预测的准确程度如何？" class="headerlink" title="如何预测值，预测的准确程度如何？"></a>如何预测值，预测的准确程度如何？</h4><p>一旦拟合出回归模型，就可以预测出响应变量Y，但是预测也有三类不确定性。</p>
<p>第一，系数估计具有不确定性，详见第二章</p>
<p>第二，线性模型是对现实的一种近似，所以存在改进可约误差的机会，线性模型假设是可约误差的来源，称为模型误差。不过我们能忽略这种差异。</p>
<p>第三，模型中不可避免的存在随机误差<script type="math/tex">\epsilon</script>，称为不可约误差。我们用预测区间来估算预测值和真实值之间的差距。预测区间总是比置行区间宽，因为预测区间既包含f(X)的估计误差（可约误差），也包含单个点偏离总体回归平面程度的不确定性（不可约误差）。</p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>定性变量（比如眼睛的颜色有棕色，蓝色等等，无法定量）</p>
<p>线性回归在定性响应变量情况下是不适用的，因为该响应变量值往往没有自然的程度顺序，顺序改变，预测结果也会改变。</p>
<h2 id="逻辑斯谛回归"><a href="#逻辑斯谛回归" class="headerlink" title="逻辑斯谛回归"></a>逻辑斯谛回归</h2><p>逻辑斯谛回归对Y属于某一类的概率建模而不直接对响应变量Y建模。</p>
<h3 id="逻辑斯谛回归模型"><a href="#逻辑斯谛回归模型" class="headerlink" title="逻辑斯谛回归模型"></a>逻辑斯谛回归模型</h3><script type="math/tex; mode=display">p(X)=\frac{e^{\beta_0+\beta_1X}}{1+e^{\beta_0+\beta_1X}}</script><p>整理上式，可得：</p>
<script type="math/tex; mode=display">\frac{p(X)}{1-p(X)}=e^{\beta_0+\beta_1X}</script><p>其值称为发生比(odd)，取值范围为0到无穷大。</p>
<p>对上式同时取对数，得：</p>
<script type="math/tex; mode=display">\log(\frac{p(X)}{1-p(X)})=\beta_0+\beta_1X</script><p>等式的左边称为<strong>对数发生比</strong>或<strong>分对数</strong>，逻辑斯谛回归可以视为分对数变换下关于X的一个线性模型。</p>
<p>p(x) 和 p 的关系并不是线性关系。</p>
<h3 id="估计回归系数-1"><a href="#估计回归系数-1" class="headerlink" title="估计回归系数"></a>估计回归系数</h3><p>但是回归模型的系数未知，必须通过有效的训练数据估计这些系数。一般采用<strong>极大似然法</strong>拟合逻辑斯谛回归模型</p>
<p>基本思想：寻找$\beta_0+\beta_1$的一个估计，使得到的预测概率最大可能的与实际预测情况接近。</p>
<p>似然函数形式如下：</p>
<script type="math/tex; mode=display">l(\beta_0,\beta_1)=\prod\limits_{i:y_i=1}p(x_i)\prod\limits_{i':y_{i'}=0}(1-p(x_{i'})</script><p>所估计的系数$\hat{\beta_0},\hat{\beta_1}$应使似然函数值最大</p>
<h3 id="多元逻辑斯谛回归"><a href="#多元逻辑斯谛回归" class="headerlink" title="多元逻辑斯谛回归"></a>多元逻辑斯谛回归</h3><p>对上面式子进行推广：</p>
<script type="math/tex; mode=display">\log(\frac{p(X)}{1-p(X)})=\beta_0+\beta_1X_1+...+\beta_nX_n</script><script type="math/tex; mode=display">p(x)=\frac{e^{\beta_0+\beta_1X_1+...+\beta_pX_p}}{1+e^{\beta_0+\beta_1X_1+...+\beta_pX_p}}</script><p>但在使用一个预测变量做逻辑斯谛回归时，如果其他预测变量与之有关系，那么预测模型会存在风险。与线性回归一样，只用一个预测变量得到的结果可能与多个预测变量得到的结果完全不一样，尤其当这些因素之间存在相关性时更是如此。这种现象称为<strong>混淆现象</strong>。</p>
<h2 id="线性判别分析"><a href="#线性判别分析" class="headerlink" title="线性判别分析"></a>线性判别分析</h2><p>在这类方法中，分别对每种响应分类（给定的Y）建立预测变量X的分布模型，然后运用贝叶斯定理反过来估计$Pr(Y=k|X=x)$</p>
<p>有了逻辑斯谛回归，为什么要用这种方法？</p>
<ol>
<li>当类别的区分度高的时候，逻辑斯谛回归模型的参数估计不够稳定，但线性判别分析不会。</li>
<li>如果样本量N比较小，而且在每一类响应分类中预测变量X近似服从正态分布，那么线性判别分析比逻辑斯谛回归模型更稳定。</li>
<li>响应分类多于两类时，线性判别分析应用更普遍。</li>
</ol>
<h3 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h3><p>$K$：观测类别数</p>
<p>$\pi_k$：一个随机选择的观测来自第 k 类的先验概率（即给定观测属于响应变量 Y 的第 k 类的概率）</p>
<p>$f_k(X)=Pr(X=x|Y=k)$：表示第 k 类观测的 X 的密度函数</p>
<p>贝叶斯定理可以表述为：</p>
<script type="math/tex; mode=display">Pr(Y=k|X=x)=\frac{\pi_kf_k(x)}{\sum\limits^k_{l=1}\pi_lf_l(x)}</script><p>记：$p_k(X)=Pr(Y=k|X)$</p>
<p>称$p_k(X)$为$X=x$的观测属于第 k 类的后验概率，即给定观测的预测变量值时，观测属于的 k 类的概率。</p>
<p>关键在于找到一个估计 $f_k(X)$的方法，发展出一个与贝叶斯类似的分类方法。</p>
<h3 id="p-1的线性判别分析"><a href="#p-1的线性判别分析" class="headerlink" title="p=1的线性判别分析"></a>p=1的线性判别分析</h3><script type="math/tex; mode=display">\hat{\mu_k}=\frac{1}{n_k}\sum\limits_{i:y_i=k}x_i</script><script type="math/tex; mode=display">\hat{\sigma^2}=\frac{1}{n-K}\sum\limits_{k=1}^K\sum\limits_{i:y_i=k}(x_i-\hat{\mu_k})^2</script><p>$\mu_k$的估计即为第k类观测的均值，而$\hat{\sigma^2}$可以视为K类样本方差的加权平均。</p>
<p>当信息不全时，LDA用属于第 k 类观测的比例估计$\pi_k$，即</p>
<p>$\hat{\pi_k}=n_k/n$</p>
<p>将上面式子代入，将观测$X=x$分入使</p>
<script type="math/tex; mode=display">\hat{\delta_k}(x)=x\frac{\hat{\mu_k}}{\hat{\sigma}^2}-\frac{\hat{\mu_k}^2}{2\hat{\sigma}^2}+log\hat{\pi_k}</script><p>最大的一类中。</p>
<p>分类器名称的“线性”一词是由于判别函数中的$\hat{\delta}_k(x)$是 x 的线性函数（而不是 x 的一个复杂函数）</p>
<h3 id="p-gt-1的线性判别分析"><a href="#p-gt-1的线性判别分析" class="headerlink" title="p&gt;1的线性判别分析"></a>p&gt;1的线性判别分析</h3><p><strong>例子：</strong></p>
<p>将 LDA 运用于数据上，根据一个人的信用卡余额和学生身份预测其违约情况。LDA 模型对 10000 个训练样本进行拟合，得到训练错误率为2.75%。但需要注意：</p>
<ol>
<li>训练错误率往往比测试错误率低，而后者才是建模的初衷。如果用分类器去预测一个新个体是否违约，可能效果会很糟糕。因为模型参数的调整过程中主要是使模型在训练数据上表现出较好的效果。而参数p与样本总数n的比值越高，模型越容易出现<strong>过拟合</strong>。</li>
<li>一个普通的零分类器（简单但可能完全无用的分类器）也会达到仅比LDA错误率高一点的效果。</li>
</ol>
<p>表中显示 LDA 一共预测了 104 人会发生违约，但事实上只有 81 人违约而 23 人并没有违约。因此没有违约的 9667 人中只有 23 个人没有被正确地标记，看起来错误率非常低，但是违约的 333 人中，通过的 LDA 后有 252（75.7%）人漏了，所以虽然总的错误率很低，但在违约的人中错误率非常高。所以违约人群 252/333=75.7% 的错误率很可能不被认可。</p>
<table>
  <tr>
    <td colspan="2" rowspan="2">&nbsp;</td>
    <td colspan="3"><center>真实违约情况</center></td>
  </tr>
  <tr>
    <td><center>没有</center></td>
    <td><center>有</center></td>
    <td><center>共计</center></td>
  </tr>
  <tr>
    <td rowspan="3"><center>预测违约情况</center></td>
    <td><center>没有</center></td>
    <td><center>9644</center></td>
    <td><center>252</center></td>
    <td><center>9896</center></td>
  </tr>
  <tr>
    <td><center>有</center></td>
    <td><center>23</center></td>
    <td><center>81</center></td>
    <td><center>104</center></td>
  </tr>
  <tr>
    <td><center>共计</center></td>
    <td><center>9667</center></td>
    <td><center>333</center></td>
    <td><center>10000</center></td>
  </tr>
</table>
灵敏度：在例子中，就是被正确判别的违约者的比例，即 23/81=24.3%

特异度：在例子中，被正确判别没有违约人的比例，即 1-23/9667=99.8%

**为什么LDA对违约者的分类效果这么差？（灵敏度低）**

答：LDA与贝叶斯分类器相似，贝叶斯分类器在不考虑错误来源时，产生的被错误分类的观测数是最少的，那么一些被错误分类的观测是源于将没有违约者分入了违约组里，而另外一些则是将违约者分入了没有违约的组。

但我们希望避免把违约者错误分类，那么可以考虑降低阈值，例如可以将后验概率在20%以上的人纳入违约组。但是会导致总错误率略微增长。

当阈值下降时，违约者的错误率平稳减少，但是未出现违约者的错误率却是增加的。**ROC曲线**可以同时展现所有可能阈值出现的两类错误。

<img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20201220162057161.png" alt="image-20201220162057161" style="zoom:67%;" />

（上图是错误率关于分类后验概率的阈值的函数。黑色实线是总错误率，蓝色虚线是违约者被错误分类的比例，橙色的点代表的是未违约者被错误分类的比例）

分类器的性能表现是通过ROC曲线下面的面积（AUC）来表示的。一个理想的ROC曲线（蓝色虚线）会紧贴左上角，所以AUC越大，分类器越好。

<img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20201220164800832.png" alt="image-20201220164800832" style="zoom:67%;" />

（ROC曲线。**真阳性率**：在给定阈值下，违约者被正确判断的比例。**假阳性率**：同样阈值下，未违约者被错误判断的比例。理想的ROC曲线应该紧贴左上角，即高的真阳性率，低的假阳性率。点虚线代表“没有信息”的分类器）

由上可以看出，不同分类器阈值会改变真阳性率和假阳性率，这也称为**灵敏度**和**1-特异度**。

<table>
  <tr>
    <td colspan="2" rowspan="2">&nbsp;</td>
    <td colspan="3"><center>预测分类</center></td>
  </tr>
  <tr>
    <td><center>-或零</center></td>
    <td><center>+或非零</center></td>
    <td><center>总计</center></td>
  </tr>
  <tr>
    <td rowspan="3"><center>真实分类</center></td>
    <td><center>-或零</center></td>
    <td><center>真阴性值(TN)</center></td>
    <td><center>假阳性值(FP)</center></td>
    <td><center>N</center></td>
  </tr>
  <tr>
    <td><center>+或非零</center></td>
    <td><center>假阴性值(FN)</center></td>
    <td><center>真阳性值(TP)</center></td>
    <td><center>P</center></td>
  </tr>
  <tr>
    <td><center>总计</center></td>
    <td><center>N*</center></td>
    <td><center>P*</center></td>
    <td>&nbsp;</td>
  </tr>
</table>


<p>与假设检验进行结合，将“-”看做零假设，而将“+”看做备择（非零）假设。在例子的背景下，“+”表示违约者，而“-”表示未违约者。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
<th>同义词</th>
</tr>
</thead>
<tbody>
<tr>
<td>假阳性率</td>
<td>FP/N</td>
<td>1-特异度</td>
</tr>
<tr>
<td>真阳性率</td>
<td>TP/P</td>
<td>灵敏度</td>
</tr>
<tr>
<td>预测阳性率</td>
<td>TP/P*</td>
<td>精确度，1-假阳性率</td>
</tr>
<tr>
<td>预测阴性率</td>
<td>TN/N*</td>
</tr>
</tbody>
</table>
</div>
<h3 id="二次判别分析"><a href="#二次判别分析" class="headerlink" title="二次判别分析"></a>二次判别分析</h3><p>QDA分类器也是假设都服从一个高斯分布，把参数估计代入贝叶斯定理进行预测。但是QDA假设每一类观测都有自己的协方差矩阵。</p>
<p><strong>为什么假设K类的协方差矩阵是否相同会有如此大的差异？</strong></p>
<p>如何选择LDA或QDA是一个偏差-方差权衡的问题。</p>
<p>当有$p$个预测变量时，预测协方差矩阵需要$p(p+1)/2$个参数，QDA需要对每一类分别估计协方差矩阵。即需要$Kp(p+1)/2$个参数。</p>
<p>然而通过假设K类的协方差矩阵相同，LDA模型对x来说是线性的，这就意味着有Kp个线性系数需要估计，所以LDA没有QDA分类器光滑，于是拥有更低的方差。</p>
<p>但需要权衡考虑：如果LDA假设K类有相同的方差是一个非常糟糕的假设，那么LDA会产生很大的偏差。一般而言，如果训练观测数据量相对较少，LDA是一个比QDA更好的决策，降低模型的方差很有必要。</p>
<p>相反的，如果训练集非常大，则更倾向于使用QDA，这时分类器的方差不再是是一个主要关心的问题，或者说K类的协方差矩阵相同的假设是站不住脚的。</p>
<p>下图说明LDA和QDA的效果。</p>
<p>左图中，两个类$X_1$和$X_2$有相同的相关系数0.7，且服从高斯分布。因此，贝叶斯决策边界是线性的，而且被LDA决策边界逼近。而QDA决策边界次之，因为其方差较大而偏差没有得到相应的减小。</p>
<p>相反的，右图中橙色部分是变量之间相关系数为0.7的类，蓝色部分是变量之间相关系数为-0.7的类。此时贝叶斯决策边界是二次的，QDA比LDA更接近这个边界。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20210110115612544.png" alt="image-20210110115612544" style="zoom:80%;" /></p>
<p>（左：协方差矩阵相等时两类分类问题的贝叶斯（紫色虚线）、LDA（黑色点线）、QDA（绿色实线）决策边界。由于贝叶斯决策边界是线性的，所以LDA比QDA更加接近真实。右：相关说明与左图一致，但协方差矩阵不相等。由于决策边界不是线性的所以QDA比LDA更加接近真实)</p>
<h2 id="分类方法的比较"><a href="#分类方法的比较" class="headerlink" title="分类方法的比较"></a>分类方法的比较</h2><p><strong>比较：</strong></p>
<ul>
<li>虽然原理不同，但是逻辑斯谛回归和 LDA 方法是紧密相连的。</li>
<li>由于逻辑斯谛回归和 LDA 只是在拟合过程中有一些差异，所以两者得到的结果应该是接近的。事实上，这一情况经常发生，但并非必然。如果近似满足高斯分布的假设，LDA 效果好；不满足则逻辑斯谛回归效果更好。</li>
<li>KNN 是一个彻底的非参数方法：对决策边界的形状没有做出任何假设。因此，当决策边界高度非线性是，用该方法会优于 LDA 和逻辑斯谛回归。而另一方面，KNN 并没有给出哪些预测变量是重要的，无法得到系数估计表</li>
<li>QDA 是非参数 KNN 方法和线性 LDA、逻辑斯谛回归方法之间的一个折中的方法。因为 QDA 得到一个二次的决策边界，所以它比线性方法的应用范围更广。QDA 在固定训练数据量的问题上一般比 KNN 有更好的效果，原因是 QDA 对决策边界的形状做了一些假设</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20201220173230742.png" alt="image-20201220173230742" style="zoom:67%;" /></p>
<p>生成100个随机训练集，每种方法进行拟合并在大的测试集中计算出结果的测试错误率。在6种情形中，预测变量个数p=2。情形如下：</p>
<p><strong>情形1：</strong></p>
<p>两类分别有20个训练观测，每一类的观测都是不相关的正态随机变量，且两类变量的均值不同。</p>
<p>LDA 表现良好，因为模型本身假设为 LDA 模型；KNN 效果较差是因为它为了降低方差付出了代价却没有在偏差上获得相应补偿；QDA 表现比 LDA 差，因为 QDA 适合光滑度更高的分类器，但在这里光滑度高的模型并不适用；逻辑斯谛回归也假设线性决策边界，所以效果只比 LDA 略微差一点。</p>
<p><strong>情形2：</strong></p>
<p>与情形1的假设一样，但两个预测变量的相关性为 -0.5。</p>
<p>结果与情形1的情况几乎没有差异。</p>
<p><strong>情形3：</strong></p>
<p>从t分布中产生两类分别 50 个观测。t分布在形状和正态分布很相似，但是它倾向于产生更多的极值点——更多的点远离均值。</p>
<p>不过决策边界仍然是线性的，所以逻辑斯谛回归框架是比较适合的；t分布的假设是于 LDA 的假设是不符的。由于观测并不来自正态分布，所以逻辑斯谛回归和 LDA 这两种方法明显优于其他方法，但逻辑斯谛回归比 LDA 效果要好一点。特别的，QDA 的效果差可以认为是非正态分布导致的结果。</p>
<p><strong>情形4：</strong></p>
<p>数据都由一个正态分布产生，在第一类中预测变量的相关系数为 0.5，在第二类中预测变量的相关系数为 -0.5</p>
<p>这个假设与 QDA 假设契合，并且产生了二次决策边界，所以优于其他方法。</p>
<p><strong>情形5：</strong></p>
<p>每类中，观测来自正态分布，预测变量不相关。然而，响应值来自逻辑斯谛函数，预测变量为$X_1^2,X_2^2,X_1X_2$。所以，这里有二次决策边界。QDA 再次表现最优的结果，KNN-CV 其次，线性模型的效果都很差。</p>
<p><strong>情形6：</strong></p>
<p>条件和情形5一样，但响应值来自更复杂的非线性函数，所以即使是 QDA 的二次决策边界也未能较好的拟合数据</p>
<p>QDA 比线性方法略好点，而光滑度更高的 KNN-CV 方法是最好的。但是 K=1 的 KNN 在所有方法里给出的结果最差。说明即使数据显示出复杂的非线性关系，如果未能选择出一个恰当的光滑系数，非参数方法如 KNN 仍然可能给出糟糕的结果。</p>
<h1 id="重抽样方法"><a href="#重抽样方法" class="headerlink" title="重抽样方法"></a>重抽样方法</h1><p>重抽样方法通过反复从训练集中抽取样本，然后对每一个样本重新拟合一个感兴趣的模型，来获取关于拟合模型的附加信息。</p>
<p>主要讨论两种最常用的重抽样方法，即<strong>交叉验证法</strong>（cross-validation）与<strong>自助法</strong>（bootstrap）</p>
<p><strong>交叉验证法</strong>可以用来估计一种指定的统计学习方法的测试误差，从而来评价这种方法的表现，或者为这种方法选择合适的光滑度。</p>
<p><strong>自助法</strong>的应用范围很广，最常用于为一个参数估计或者一个指定的统计学习方法提供关于准确度的测量。</p>
<p>评价一个模型表现的过程被称为<strong>模型评价</strong>（model assessment），而为一个模型选择合适的光滑度的过程则被称为<strong>模型选择</strong>（model selection）</p>
<h2 id="交叉验证法"><a href="#交叉验证法" class="headerlink" title="交叉验证法"></a>交叉验证法</h2><p>测试误差是一种统计学习方法预测在一个新的预测上的响应值所产生的平均误差。如果一个统计学习方法产生了一个较小的测试误差，那么其可用性值得肯定。</p>
<p>不过我们一般无法事先指定一个测试数据集来计算测试误差，虽然可以计算训练误差，但是训练错误率通常跟测试错误率有很大差别，尤其是表现为前者可能会严重的低估后者。</p>
<p><strong>方法：</strong>在拟合过程中，保留（holding out）训练观测的一个子集，然后对保留的观测运用统计学习方法，从而估计其测试错误率。</p>
<h3 id="验证集方法"><a href="#验证集方法" class="headerlink" title="验证集方法"></a>验证集方法</h3><p><strong>验证集方法（validation set approach）：</strong>首先随机的把可获得的观测集分为两部分：一个<strong>训练集</strong>（training set）和一个<strong>验证集</strong>（validation set），或者说是<strong>保留集</strong>（hold-out set）。模型在训练集上拟合，然后用拟合的模型来预测验证集中观测的响应变量。最后得到的验证集错误率——通常用均方误差作为定量响应变量的误差度量——提供了对于测试错误率的一个估计。</p>
<p>（简单讲就是数据分为两部分，一部分用于训练，一部分用于测试）</p>
<p>验证集方法的原理很简单，且易于执行。但它有两个潜在的缺陷：</p>
<ol>
<li>测试错误率的验证方法估计的波动很大，这取决于具体哪些观测被包括在训练集中，哪些观测被包括在验证集中。</li>
<li>在验证法中，只有包含在训练集的观测被用于拟合模型。由于被训练的观测越少，统计方法的表现越不好，这意味着，验证集错误率可能会高估在整个数据集上拟合模型所得到的测试错误率。</li>
</ol>
<h3 id="留一交叉验证法"><a href="#留一交叉验证法" class="headerlink" title="留一交叉验证法"></a>留一交叉验证法</h3><p><strong>留一交叉验证法（leave-one-out cross-validation，LOOCV）</strong>：将一个单独的观测作为验证集，再对余下的观测根据它的值来做预测，然后重复这个步骤。重复方法n次得到n个均方误差，对测试误差的LOOCV估计是这n个测试误差估计的均值：</p>
<script type="math/tex; mode=display">CV_{(n)}=\frac{1}{n}\sum^n\limits_{i=1}MSE_i</script><p>（简单讲就是数据分出来1个当作预测数据，剩下数据用于训练；每次分出不同的1个数据，重复n次）</p>
<p>相对于验证集方法的优点：</p>
<ol>
<li>它的偏差较小，因为它的观测数几乎与整个数据集中的数据量相等，因此更不容易高估测试错误率。</li>
<li>由于训练集和验证集分割的随机性，验证集方法重复运用时会产生不同结果；而多次运用 LOOCV 方法总会得到相同的结果，因为分割上不存在随机性。</li>
</ol>
<h3 id="k折交叉验证法"><a href="#k折交叉验证法" class="headerlink" title="k折交叉验证法"></a>k折交叉验证法</h3><p><strong>k折交叉验证法（k-fold CV）</strong>是 LOOCV 方法的一个替代：将观测集随机的分为k个大小基本一致的组，或者说<strong>折</strong>（fold）。一折作为验证集，然后在剩下折上拟合模型。均方误差由保留折的观测计算得出。重复方法k次得到k个均方误差，从而得到k个测试误差估计的均值。</p>
<p>（简单讲就是数据分成许多组，每次选一组作为预测数据，其余类似留一交叉验证法）</p>
<p>使用交叉验证法时，其目的可能是想评价某一种指定的统计学习方法在独立数据运用上的表现：在这种情况下，感兴趣的是测试均方误差的估计精度。而在其他的一些情况下，可能仅仅对<strong>测试均方误差曲线的最小值点</strong>（mininum point in the estimated test MSE curve）的位置感兴趣。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20201222152009794.png" alt="image-20201222152009794" style="zoom:67%;" /></p>
<p>（图中蓝色实线为测试均方误差的真值，黑色虚线为 LOOCV 的估计值，橙色实线为 10 折 CV 估计值。用“X”标注的点表示每条均方误差曲线的最小值点）</p>
<p>上图表明，尽管有时会低估测试均方误差的真值，但所以 CV 曲线都非常接近于确认光滑度水平的模型，即对应最小的测试均方误差的模型光滑度水平。</p>
<h2 id="自助法"><a href="#自助法" class="headerlink" title="自助法"></a>自助法</h2><p>自助法可以用来衡量一个指定的估计量或统计学习方法中不确定的因素。但在线性回归的情况下，自助法可能不是特别有用。</p>
<p>相比从总体中反复的得到独立的数据集，自助法通过反复的从<strong>原始数据集</strong>（original data set）中抽取观测得到的结果。</p>
<p><strong>例：</strong></p>
<p>在一个只包含n=3个观测的简单数据集Z上，随机的选择n个观测，来产生一个自助法数据集。抽样通过有放回（replacement）的方式进行，也就意味着同一个观测可能多次出现在自助法数据集中，比如第一个数据集包含了两次第三个观测，一次第一个观测，而没有第二个观测。这个步骤重复B次，其中B是一个很大的值，就可以产生B个不同的自助法数据集和B个相应的$\alpha$估计，然后用下式计算自助法估计的标准误差：</p>
<script type="math/tex; mode=display">SE_B(\hat{\alpha})=\sqrt{\frac{1}{B-1}\sum^B\limits_{r=1}(\hat{\alpha}^{*r}-\frac{1}{B}\sum^B\limits_{r=1}\hat{\alpha}^{*r'})^2}</script><p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20201222152738148.png" alt="image-20201222152738148" style="zoom:67%;" /></p>
<p>（每一个自助法数据集包含n个观测，从原始数据集中有放回的抽样得到。用每个自助法数据集得到一个包含$\alpha$的估计）</p>
<p><strong>数据集中样本在n次始终不被采样到的概率？</strong></p>
<p>概率是$(1-\frac{1}{n})^n$</p>
<p>取极限为0.368</p>
<p><strong>优缺点：</strong></p>
<ul>
<li>数据集小、难以划分训练\测试集</li>
<li>自助法能从初始数据集中产生多个不同的训练集，可以用于集成学习</li>
<li>自助法产生的训练集改变了初始数据集的分布，会引入估计偏差</li>
</ul>
<h1 id="压缩估计方法"><a href="#压缩估计方法" class="headerlink" title="压缩估计方法"></a>压缩估计方法</h1><p>我们可以使用对系数进行约束或惩罚的技巧对包含p个预测变量的模型进行拟合。</p>
<h2 id="岭回归-ridge-regression"><a href="#岭回归-ridge-regression" class="headerlink" title="岭回归(ridge regression)"></a>岭回归(ridge regression)</h2><p>在线性回归中通过最小化进行估计来拟合最小二乘回归。</p>
<p>岭回归系数估计值$\hat{\beta}^R$通过最小化公式得到：</p>
<script type="math/tex; mode=display">\sum^n\limits_{i=1}(y_i-\beta_0-\sum^p\limits_{j=1}\beta_jx_{ij})^2+\lambda\sum^p\limits_{j=1}\beta^2_j=RSS+\lambda\sum^p\limits_{j=1}\beta^2_j</script><p>其中$\lambda\geq0$是一个调节参数(tuning parameter)，将单独确定。</p>
<p>与最小二乘相同，岭回归通过最小化RSS寻求能较好的拟合数据的估计量。</p>
<p>$\lambda\sum^p\limits_{j=1}\beta^2_j$称为压缩惩罚</p>
<p><strong>为什么使用岭回归会提升最小二乘的效果？</strong></p>
<p>与最小二乘相比，岭回归的优势在于它综合权衡了误差与方差。随着$\lambda$的增加，岭回归拟合结果的光滑度降低，虽然方差降低，但是偏差在增加。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20210108181734362.png" alt="image-20210108181734362"></p>
<p>（图中显示了岭回归在模拟测试集上预测结果的偏差的平方（黑线）、方差（绿线）和测试均方误差（紫线）随着$\lambda$的变化情况。水平的虚线表示 MSE 可能的最低水平。紫线与虚线的交点表示均方误差最低时对应岭回归模型）</p>
<h2 id="lasso"><a href="#lasso" class="headerlink" title="lasso"></a>lasso</h2><p>岭回归的一个显著的劣势在于：岭回归的模型包含全部的p个变量，不能剔除不重要的变量。当变量个数非常大时，不便于模型解释。</p>
<p>lasso的系数通过下式得到：</p>
<script type="math/tex; mode=display">\sum^n\limits_{i=1}(y_i-\beta_0-\sum^p\limits_{j=1}\beta_jx_{ij})^2+\lambda\sum^p\limits_{j=1}|\beta_j|=RSS+\lambda\sum^p\limits_{j=1}|\beta_j|</script><p>与岭回归相同，lasso也将系数估计值往0的方向进行缩减。然而，当调节参数$\beta$足够大时，惩罚项具有将其中某些系数的估计值强制设定为0的作用。所以lasso也完成了变量选择。</p>
<p><strong>对比lasso和岭回归</strong></p>
<p>如果预测变量都与响应变量有关，lasso的结果和岭回归在性质上类似。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20210108165341097.png" alt="image-20210108165341097" style="zoom:80%;" /></p>
<p>一般情况下，当一小部分预测变量是真实有效的而其他预测变量系数非常小或者等于零时，lasso要更为出色；当响应变量是很多预测变量的函数并且这些变量系数大致相等时，岭回归较为出色。</p>
<p>与岭回归相比，当最小二乘出现较大方差时，lasso以牺牲偏差为代价去降低方差，从而得到更为精确的预测结果。lasso不同于岭回归，它进行变量选择，因此得到的模型更容易解释。</p>
<h1 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h1><p>多项式函数：</p>
<script type="math/tex; mode=display">y_i=\beta_0+\beta_1x_i+\beta_2x_i^2+\beta_3x_i^3+...+\beta_dx_i^d+\varepsilon_i</script><h1 id="基于树的方法"><a href="#基于树的方法" class="headerlink" title="基于树的方法"></a>基于树的方法</h1><p>主要根据分层和分割的方式将预测变量空间划分为一系列简单区域。对某个给定待预测的观测值，用它所属区域中训练集的平均值或众数对其进行进行预测。由于划分预测变量空间的分裂规则可以被概括为一棵树，所以这类方法被称为<strong>决策树</strong>（decision tree）方法</p>
<h2 id="决策树基本原理"><a href="#决策树基本原理" class="headerlink" title="决策树基本原理"></a>决策树基本原理</h2><h3 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h3><p><strong>通过特征空间分层预测</strong></p>
<p>建立回归树的过程大致可以分为两步</p>
<ol>
<li>将预测变量空间分割成 J 个不重叠的区域</li>
<li>对落入区域$R_j$的每个观测值作同样的预测，预测值等于$R_j$上训练集的响应值的简单算术平均</li>
</ol>
<p><strong>树的剪枝</strong></p>
<p>上述方法会在训练集中取得良好的预测效果，却很有可能造成数据的过拟合，导致在测试集上效果不佳。原因在于树过于复杂。一颗分裂点更少，规模更小的树会有更好的方差和更好的可解释性（以增加微小偏差为代价）。</p>
<h3 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h3><p>分类树用于预测定性变量而非定量变量。</p>
<p>分类树采用递归二叉分裂，但在分类树中，RSS 无法作为确定二叉分裂点的准则。替代指标是<strong>分类错误率</strong>（classification error rate）既然要将给定区域内的观测值都分到此区域的训练集上最常出现的类中，那么分类错误率的定义为：此区域的训练集中非最常见类所占的比例。</p>
<p>分类错误率：此区域的训练集中非最常见类所占用的比例。表达式如下：</p>
<script type="math/tex; mode=display">E=1-max(\hat{p}_{mk})</script><p>上式中的$\hat{p}_{mk}$代表第 m 个区域的训练集中第 k 类所占比例。但分类错误率在构建树时不够敏感。有另外两个指标更有优势。</p>
<p><strong>基尼系数</strong>（Gini index）定义如下：</p>
<script type="math/tex; mode=display">G=\sum^K\limits_{k=1}\hat{p}_{mk}(1-\hat{p}_{mk})</script><p>它衡量的是 K 个类别的总方差。如果$\hat{p}_{mk}$的取值都接近0或1，基尼系数会很小，因此基尼系数被视为衡量结点<strong>纯度</strong>（purity）指标——如果它较小，就意味着某个包含的观测值几乎都来自同一系列。</p>
<p>可以替代基尼系数的指标是<strong>互熵</strong>（cross-entropy），定义如下：</p>
<script type="math/tex; mode=display">D=-\sum\limits_{k=1}^k\hat{p}_{mk}\log\hat{p}_{mk}</script><p>基尼系数和互熵都是用于衡量某特定分裂点的分类质量。</p>
<p>这两种方法对结点纯度更敏感。不过若想追求较高的预测准确性，最好选择分类错误率指标。</p>
<h3 id="树与线性模型的比较"><a href="#树与线性模型的比较" class="headerlink" title="树与线性模型的比较"></a>树与线性模型的比较</h3><p>哪一种更好，要视具体情况而定。如果预测变量和响应变量间的关系能很好的用线性模型来拟合，那么线性回归通常有不错的效果，拟合效果将优于不能揭示线性结构的回归树。反正，若预测变量和响应变量的关系呈现出复杂的高度非线性，那么树的方法则比传统方法略胜一筹。</p>
<h3 id="树的优缺点"><a href="#树的优缺点" class="headerlink" title="树的优缺点"></a>树的优缺点</h3><ul>
<li>决策树解释性强，在解释性方面甚至比线性回归更方便</li>
<li>有人认为与传统的回归和分类方法相比，决策树更接近人的决策模式</li>
<li>树可以用图形表示</li>
<li>树可以直接处理定性的预测变量而不需创建哑变量</li>
<li>缺点：树的预测准确性一般无法达到其他回归和分类方法的水平</li>
</ul>
<h1 id="19年期末考试"><a href="#19年期末考试" class="headerlink" title="19年期末考试"></a>19年期末考试</h1><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>第一题画出有一个预测变量的线性回归线（草图即可）。</p>
<p>第二题画出有两个预测变量的多项式回归线（草图即可）。</p>
<p>第三题画出有三个预测变量的多项式回归线（草图即可）。</p>
<p>第四题设计一个模型，使得它的总是等于0</p>
<p>第五题对前三题的模型进行灵活度（Flexibility）排序（1&lt;2&lt;3）</p>
<p>第六题，数据来自二次项式，对前三题的模型进行MSE排序</p>
<p>第七题，画出训练数据点，问不同训练数据对模型拟合出来的预测值的影响（模型存在方差，训练数据集微小的变化会导致预测值改变）</p>
<p>第八题，写出偏差（Bias）和方差（var）的表达式，并用偏差-方差权衡公式解释第六题的排序</p>
<p>第九题，随模型的灵活性变大， train MSE 减小，而 test MSE 反而增加，这种现象叫什么?（过拟合）</p>
<p>第十题，画出测试MSE、方差、偏差随灵活性增加发生的变化，并标注测试MSE最低点位置。</p>
<p>第十一题，写出岭回归和lasso的惩罚项。</p>
<p>第十二题，lasso相对于岭回归的优点，为什么会有这个优点？</p>
<p>第十三题，岭回归的参数是什么？画出测试MSE、方差、偏差的平方随参数的增加的曲线</p>
<p>第十四题，画出KNN回归曲线（应该不考）</p>
<h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><p>第一题，给出五个数据点，画点（送分题）</p>
<p>第二题，画出任意一条分界线把两类完全分开（送分）</p>
<p>第三题，向量机有关</p>
<p>第四题，向量机有关</p>
<p>第五题，向量机有关</p>
<p>第六题，向量机有关</p>
<p>第七题，问逻辑斯谛回归的分类线是直线吗？为什么？</p>
<p>第八题，向量机有关</p>
<p>第九题，向量机有关</p>
<p>第十题，向量机有关</p>
<h1 id="18年期末考试"><a href="#18年期末考试" class="headerlink" title="18年期末考试"></a>18年期末考试</h1><p>答案仅供参考，可能有误，且只有部分题目做出。</p>
<h2 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h2><p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20210108193810730.png" alt="image-20210108193810730" style="zoom:80%;" /></p>
<ol>
<li>应该是对的</li>
<li>应该是错的，不一定最佳</li>
<li>对</li>
<li>对，零截距回归模型，又称过原点回归模型</li>
<li>应该是对的</li>
<li>错，说反了</li>
<li>应该是对的</li>
<li>错</li>
<li>对</li>
<li>错，不成线性关系</li>
</ol>
<h2 id="多项式回归-1"><a href="#多项式回归-1" class="headerlink" title="多项式回归"></a>多项式回归</h2><p>第一题画出一元线性回归曲线（不需要计算参数，尽量准确画出）</p>
<p>第二题画出多项式曲线（不需要计算参数，尽量准确画出）</p>
<p>第三题数据来源于一元线性模型，比较上面两个模型在某个测试点的Squared Error哪个小（应该差不多吧，不会）;测试MSE呢（应该是一元线性回归小，毕竟真实的 f 是线性的，线性回归基本上没有误差）</p>
<p>第四题数据来源于非线性模型，画出训练MSE(training MSE)与模型灵活度的走势图（答案：图参考书P25，图2-12右图）</p>
<h2 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h2><p>第一题在图中画出贝叶斯决策边界（参考书P98，图4-4）</p>
<p>第二题画出给出参数值，在0.5下，画出逻辑斯谛回归分界线，算出边界值（根据公式算）</p>
<p>第三题填充混淆矩阵</p>
<p>第四题画出ROC曲线（熟悉特异度，灵敏度，TP，FP，N，P）</p>
<h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><p>考编程（本次考试不考编程）</p>
<h2 id="自举法"><a href="#自举法" class="headerlink" title="自举法"></a>自举法</h2><p>第一题抽取学生体重的一个体重样本，算均值（应该就算平均值就行）</p>
<p>第二题获得一个自举样本（详见自助法，应该是随便取，只要符合规则）</p>
<p>第三题问数据集中样本在n次始终不被采样到的概率大于0.5还是小于0.5？并写出公式（概率是$(1-\frac{1}{8})^8=0.3436$，公式是$(1-\frac{1}{n})^n$，极限值为0.368）</p>
<h1 id="18年期中考试"><a href="#18年期中考试" class="headerlink" title="18年期中考试"></a>18年期中考试</h1><p>答案仅供参考，可能有误，且只有部分题目做出。</p>
<h2 id="判断题-1"><a href="#判断题-1" class="headerlink" title="判断题"></a>判断题</h2><ol>
<li><p><strong>某学习方法的训练错误率(training error rate)低，那么它的测试错误率(test error rate)也低。</strong></p>
<p>错，训练错误率往往比测试错误率低</p>
</li>
<li><p><strong>用来说明偏差-方差权衡(Bias-Variance trade-off)的公式是这样的，$E[(y_0− \hat{f}(x_0))^2]=Var( \hat{f}(x_0))+[Bias(\hat{f}(x_0))]^2+Var(\epsilon)$。它告诉我们，学习方法越灵活(flexible)，测试MSE(Mean Squared Error)的期望就越小。</strong></p>
<p>错，一般而言，使用光滑度(flexible)越高的方法，所得的模型方差会增加，偏差会减少。这两个量比值的相对变化率会导致测试均方误差整体的增加或变小，所以偏差-方差的权衡是一个重要探讨主题。因此不是学习方法越灵活，测试MSE的期望就越小。</p>
</li>
<li><p><strong>即使我们不能确定训练数据是线性的，也照样可以作线性回归。$R^2 = \frac{TSS − RSS}{TSS}$ 代表线性回归所解释的响应变量 Y 的方差的比例。</strong></p>
<p>对</p>
</li>
<li><p><strong>在训练数据${(x_1, y_1),(x_2, y_2), …,(x_n, y_n)}$上做一元线性回归(simple linear regression)， 拟合得到的直线$(\hat{Y}= \hat{\beta}_0 + \hat{\beta}_1X)$通过点$(\overline{x}, \overline{y})$。其中$\overline{x}$是所有$x_i$的平均值，即$\overline{x} = \frac{1}{n}\sum^n\limits_{i=1}x_i，\overline{y}$是 所有$y_i$的平均值，即$\overline{y} = \frac{1}{n}\sum^n\limits_{i=1}y_i$。</strong></p>
<p>对</p>
</li>
<li><p><strong>一元线性回归中参数$\beta_1$对应的 $p-value$越小，表明拒绝 $H_a : \beta_1 \neq 0$ 的能力越强。多元 线性回归中$F$值越大，表明拒绝$H_0 : \beta_1 = \beta_2 = · · · = \beta_p = 0$的能力越强。</strong></p>
<p>应该是对的</p>
</li>
</ol>
<h2 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h2><p><strong>一元线性回归与测试MSE(Mean Squared Error)的期望。在非线性数据上作一元线性回归，并且讨论某测试点MSE期望的下界。</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="/images/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/image-20201222165612058.png" alt="image-20201222165612058" style="zoom:67%;" /></p>
<ol>
<li><p><strong>用最小二乘法(least squares)方法估算一元线性回归参数，$\hat{\beta}_0 =\overline{y} − \hat{\beta}\overline{x}，\hat{\beta}_1 = \frac{\sum^n_{i=1}(x_i-\overline{x})(y_i\overline{y})}{\sum^n_{i=1}(x_i-\overline{x})^2}$。给定$D = {(−0.38, 1.34),(0.93, 1.24),(2.63, 6.94)}$，对应下图中3个加号，求$\hat{\beta}_0与\hat{\beta}_1$的值（精确到小数点后2位数）。</strong></p>
<p>答：根据公式解：</p>
<script type="math/tex; mode=display">\hat{\beta_1}=\frac{\sum^{n}\limits_{i=1}{(x_i-\overline{x})(y_i-\overline{y})}}{\sum^{n}\limits_{i=1}{(x_i-\overline{x})^2}}</script><script type="math/tex; mode=display">\hat{\beta_0}=\overline{y}-\hat{\beta_1}\overline{x}</script></li>
<li><p><strong>在上图画一条最小二乘法(least squares)拟合的直线，其表达式是 $\hat{f}(X) = \hat{\beta}_0+\hat{\beta}_1X$。</strong> </p>
<p>略</p>
</li>
<li><p><strong>计算上述直线在D上的$R^2$的值。$R^2=\frac{TSS-RSS}{TSS}= \frac{\sum(\hat{y}_i-\overline{y})^2}{\sum(y_i-\overline{y})^2}$。</strong></p>
<p>略</p>
</li>
<li><p><strong>图中的3个点来自真正函数$f(X) = 0.5 + 1.5X + 0.25X^2$，见上图灰色曲线。 $\hat{f}$由一 元线性模型$Y = \hat{\beta}_0+\hat{\beta}_1X+\epsilon$在任3个训练点上训练所得。已知$E[  \hat{f}(−1)] = −0.30$。求在测试点$x_0 = −1$处的$|Bias( \hat{f}(−1))|$。</strong></p>
<p>该题应该先根据$E[  \hat{f}(−1)] = −0.30$与前题求得的$\beta$值，求出$\epsilon$值，再求偏差</p>
</li>
<li><p>求MSE期望下界</p>
</li>
</ol>
<h2 id="推导题"><a href="#推导题" class="headerlink" title="推导题"></a>推导题</h2><ol>
<li>推导最小二乘法公式</li>
<li>（不懂）</li>
<li>说明一元线性模型得到的残差之和为0</li>
<li>无截距模型具备题三个性吗？为什么</li>
</ol>
<h2 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h2><p>（关于莱特希尔报告）</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>蓝珲说都是重点，应该是对的，因为考试可能都要考：）</li>
<li>书上的知识点，结论很重要，可能会考</li>
<li>书上的图也很重要，可能会考</li>
<li>蓝珲的考试，画图题很多</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Leonlist</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/12/04/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/">http://yoursite.com/2020/12/04/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2019/11/10/lP3rLNUBaGtSVzc.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/09/%E5%85%AD%E7%BA%A7/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2019/11/10/egVhFWopA5mP2Hk.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">六级</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/04/Java%E5%A4%8D%E4%B9%A0/"><img class="next-cover" data-lazy-src="https://i.loli.net/2019/11/10/xthHmnbdNerWOqP.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Java复习</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/12/15/人工智能-智能作业批改Aita/" title="人工智能-智能作业批改Aita"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2019/11/10/gcnavZbmepS8d4u.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-15</div><div class="relatedPosts_title">人工智能-智能作业批改Aita</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Leonlist</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>